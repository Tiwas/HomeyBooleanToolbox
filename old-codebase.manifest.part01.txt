--- START: .homeychangelog.json (sha256=3e955bb338ffaaa2d6cb1af96271983973218805eb6a5ad6ce85389797c64ac7, bytes=963) ---
{
  "0.5.0": {
    "en": "First release"
  },
  "0.5.1": {
    "en": "Visuals"
  },
  "0.7.0": {
    "en": "It should now actually work..."
  },
  "1.0.0": {
    "en": "Support for 10 inputs, some awesome cards to deal with rapidly changing inputs and much more!"
  },
  "1.1.0": {
    "en": "MAJOR UPDATE: Each formula now has its own isolated input state! New 'First Impression' mode locks inputs at first value. Added timeout detection and manual re-evaluation. ⚠️ Breaking changes - recommended to create new devices."
  },
  "1.1.1": {
    "en": "Machine translated languages"
  },
  "1.2.0": {
    "en": "Logic device with visual pairing, dynamic number of inputs, JSON auto-formatting, lots of improvements, rewritten, more efficient code++"
  },
  "1.2.1": {
    "en": "Bug fixes. Mostly regex optimization, but also re-evaluation after changing formulas."
  },
  "1.2.2": {
    "en": "Added a couple of cards for evaluation and error control."
  }
}
--- END: .homeychangelog.json ---

--- START: app.js (sha256=e4cf909dd56785f5b2721c0e5bac36e2b93e6cb8466230287d67285b5a368d03, bytes=14765) ---
'use strict';

const Homey = require('homey');

function evaluateCondition(inputValue, operator, ruleValue) {
  switch (operator) {
    case 'gt': return inputValue > ruleValue;
    case 'gte': return inputValue >= ruleValue;
    case 'lt': return inputValue < ruleValue;
    case 'lte': return inputValue <= ruleValue;
    default: return false;
  }
}

 module.exports = class BooleanToolboxApp extends Homey.App {

  async onInit() {
    this.log('Boolean Toolbox has been initialized');
    
    // Initialize API for accessing all devices
    try {
      const athomApi = require('athom-api');
      this.log('athom-api loaded successfully');
      
      // Get HomeyAPI from the exported object
      const { HomeyAPI } = athomApi;
      this.log('HomeyAPI extracted, type:', typeof HomeyAPI);
      
      if (typeof HomeyAPI.forCurrentHomey === 'function') {
        this.log('Initializing HomeyAPI.forCurrentHomey...');
        this.api = await HomeyAPI.forCurrentHomey(this.homey);
        this.log('✅ Homey API initialized successfully');
      } else {
        this.error('HomeyAPI.forCurrentHomey is not a function');
        this.error('HomeyAPI methods:', Object.keys(HomeyAPI));
      }
    } catch (e) {
      this.error('Failed to initialize Homey API:', e.message);
      this.error('Error stack:', e.stack);
    }
    
    await this.registerFlowCards();
  }

  async getAvailableZones() {
    this.log('[APP] Getting available zones...');
    try {
      if (!this.api) {
        const athomApi = require('athom-api');
        const { HomeyAPI } = athomApi;
        this.api = await HomeyAPI.forCurrentHomey(this.homey);
      }
      const zones = await this.api.zones.getZones();
      const zoneList = Object.values(zones).map(zone => ({
        id: zone.id,
        name: zone.name,
      }));
      zoneList.sort((a, b) => a.name.localeCompare(b.name));
      this.log(`[APP] ✅ Found ${zoneList.length} zones`);
      return zoneList;
    } catch (e) {
      this.error('[APP] ❌ Error getting zones:', e.message);
      return [];
    }
  }

  async getDevicesInZone(zoneId) {
    this.log(`[APP] Getting devices for zone ID: ${zoneId}`);
    const deviceList = [];
    try {
      if (!this.api) {
        const athomApi = require('athom-api');
        const { HomeyAPI } = athomApi;
        this.api = await HomeyAPI.forCurrentHomey(this.homey);
      }
      
      const allDevices = await this.api.devices.getDevices();
      for (const deviceId in allDevices) {
        const device = allDevices[deviceId];
        if (device.zone !== zoneId) continue; // Hopp over enheter som ikke er i den valgte sonen
        if (device.driverUri?.includes('logic-device')) continue;
        
        const capabilities = device.capabilities || [];
        if (capabilities.length === 0) continue;
        
        const capabilityList = capabilities.map(cap => {
          const capObj = device.capabilitiesObj?.[cap];
          return {
            id: cap,
            name: capObj?.title || cap.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            type: capObj?.type || 'unknown'
          };
        });

        deviceList.push({
          id: deviceId,
          name: device.name,
          driverName: device.driverUri?.split(':').pop() || 'Unknown',
          capabilities: capabilityList
        }); 
      }
      
      deviceList.sort((a, b) => a.name.localeCompare(b.name));
      this.log(`[APP] ✅ Found ${deviceList.length} devices in zone ${zoneId}`);
    } catch (e) {
      this.error(`[APP] ❌ Error getting devices for zone ${zoneId}:`, e.message);
    }
    return deviceList;
  }

  async registerFlowCards() {
    // Register STATE CHANGED trigger (NYTT)
    const stateChangedCard = this.homey.flow.getDeviceTriggerCard('device_state_changed');
    
    // Register TRIGGER cards
    const formulaTrueCard = this.homey.flow.getDeviceTriggerCard('formula_changed_to_true');
    
    formulaTrueCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    formulaTrueCard.registerRunListener(async (args, state) => {
      return !state || !args.formula || args.formula.id === state.formulaId;
    });

    const formulaFalseCard = this.homey.flow.getDeviceTriggerCard('formula_changed_to_false');
    
    formulaFalseCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    formulaFalseCard.registerRunListener(async (args, state) => {
      return !state || !args.formula || args.formula.id === state.formulaId;
    });
    
    const formulaTimeoutCard = this.homey.flow.getDeviceTriggerCard('formula_timeout');
    
    formulaTimeoutCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    formulaTimeoutCard.registerRunListener(async (args, state) => {
      return !state || !args.formula || args.formula.id === state.formulaId;
    });

    // Register SET INPUT action (sets input for specific formula)
    const setInputCard = this.homey.flow.getActionCard('set_input_value');
    
    setInputCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    setInputCard.registerArgumentAutocompleteListener('input', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const inputs = device.getInputOptions();
      
      if (!query) return inputs;
      
      return inputs.filter(i => 
        i.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    setInputCard.registerRunListener(async (args) => {
      const device = args.device;
      
      if (!device) {
        throw new Error('Could not find device. Please reconfigure this flow card.');
      }
      
      const formulaId = args.formula.id;
      
      const formula = device.formulas?.find(f => f.id === formulaId);
      if (!formula) {
        throw new Error(`Formula '${formulaId}' not found. Please reconfigure this flow card with an existing formula.`);
      }
      
      await device.setInputForFormula(formulaId, args.input.id, args.value === 'true');
      return true;
    });

    // Register EVALUATE FORMULA action
    const evaluateFormulaCard = this.homey.flow.getActionCard('evaluate_formula');
    
    evaluateFormulaCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    evaluateFormulaCard.registerRunListener(async (args) => {
      const device = args.device;
      
      if (!device) {
        throw new Error('Could not find device. Please reconfigure this flow card.');
      }
      
      const formulaId = args.formula.id;
      
      const formula = device.formulas?.find(f => f.id === formulaId);
      if (!formula) {
        throw new Error(`Formula '${formulaId}' not found. Please reconfigure this flow card with an existing formula.`);
      }
      
      await device.evaluateFormula(formulaId, true);
      return true;
    });

    // Register EVALUATE ALL FORMULAS action
    const evaluateAllCard = this.homey.flow.getActionCard('evaluate_all_formulas');
    
    evaluateAllCard.registerRunListener(async (args) => {
      const device = args.device;
      
      if (!device) {
        throw new Error('Could not find device. Please reconfigure this flow card.');
      }
      
      await device.evaluateAllFormulas();
      return true;
    });

    // Register CONDITION card (formula_result_is)
    const conditionCard = this.homey.flow.getConditionCard('formula_result_is');
    
    conditionCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    conditionCard.registerRunListener(async (args) => {
      const device = args.device;
      
      if (!device) {
        this.error('Condition: Could not find device', args);
        throw new Error('Could not find device. Please reconfigure this flow card.');
      }
      
      const formulaId = args.formula.id;
      
      const formula = device.formulas?.find(f => f.id === formulaId);
      if (!formula) {
        this.error(`Condition: Formula '${formulaId}' not found`);
        throw new Error(`Formula '${formulaId}' not found. Please reconfigure this flow card with an existing formula.`);
      }
      
      const result = device.getFormulaResult(formulaId);
      
      this.log(`Condition check: Formula '${formulaId}' result = ${result}, checking if ${args.what_is}`);
      
      if (result === null || result === undefined) {
        this.log(`Condition: Formula '${formulaId}' has not been evaluated yet (result is ${result})`);
        return false;
      }
      
      return result.toString() === args.what_is;
    });
    
    // Register CONDITION card (formula_has_timed_out)
    const timeoutConditionCard = this.homey.flow.getConditionCard('formula_has_timed_out');
    
    timeoutConditionCard.registerArgumentAutocompleteListener('formula', async (query, args) => {
      const device = args.device;
      if (!device) return [];
      
      const formulas = device.getFormulas();
      
      if (!query) return formulas;
      
      return formulas.filter(f => 
        f.name.toLowerCase().includes(query.toLowerCase())
      );
    });
    
    timeoutConditionCard.registerRunListener(async (args) => {
      const device = args.device;
      
      if (!device) {
        throw new Error('Could not find device. Please reconfigure this flow card.');
      }
      
      const formulaId = args.formula.id;
      
      const formula = device.formulas?.find(f => f.id === formulaId);
      if (!formula) {
        throw new Error(`Formula '${formulaId}' not found. Please reconfigure this flow card with an existing formula.`);
      }
      
      return device.hasFormulaTimedOut(formulaId);
    });

    // --- Registrer handlingskortet ---
    const evaluateActionCard = this.homey.flow.getActionCard('evaluate_expression');
    
    evaluateActionCard.registerRunListener(async (args, state) => {
        const { input, rules, op1, op2, logical_op } = args;
        
        // Nullstill verdier ved start for en ren kjøring hver gang
        await evaluateActionCard.setTokenValue('outputValue', 0);
        await evaluateActionCard.setTokenValue('errorMessage', '');

        try {
            this.log(`Running evaluation. Input: ${input}, Rules: '${rules}'`);
            let output = null;

            if (!rules || rules.trim() === '') {
              throw new Error("Regel-strengen kan ikke være tom.");
            }
            
            const ruleSets = rules.split(';').map(set => set.trim()).filter(set => set.length > 0);

            for (const ruleSet of ruleSets) {
                const parts = ruleSet.split(',');
                if (parts.length !== 3) {
                  throw new Error(`Ugyldig format i regelen '${ruleSet}'. Forventet 'min,maks,utgang'.`);
                }

                const min = parseFloat(parts[0]);
                const max = parseFloat(parts[1]);
                const resultValue = parseInt(parts[2], 10);

                if (isNaN(min) || isNaN(max) || isNaN(resultValue)) {
                  throw new Error(`Ugyldig tallverdi i regelen '${ruleSet}'.`);
                }

                const condition1 = evaluateCondition(input, op1, min);
                const condition2 = evaluateCondition(input, op2, max);

                let ruleMatched = (logical_op === 'AND')
                    ? (condition1 && condition2)
                    : (condition1 || condition2);

                if (ruleMatched) {
                    output = resultValue;
                    break;
                }
            }

            if (output !== null) {
                this.log(`Evaluation finished. Output: ${output}`);
                await evaluateActionCard.setTokenValue('outputValue', output);
            } else {
                const logicalErrorMsg = `Verdien ${input} er utenfor definert logikk.`;
                this.log(logicalErrorMsg);
                await evaluateActionCard.setTokenValue('errorMessage', logicalErrorMsg);
            }

        } catch (e) {
            this.log(`Configuration error caught: ${e.message}`);
            await evaluateActionCard.setTokenValue('errorMessage', `Feil i konfigurasjon: ${e.message}`);
        }
        
        return true;
    });

    // --- Registrer betingelseskortet ---
    const hasErrorConditionCard = this.homey.flow.getConditionCard('has_error');
    hasErrorConditionCard.registerRunListener(async (args, state) => {
      const textInput = args.text_input;
      const hasError = !!textInput && textInput.length > 0;
      this.log(`Checking for error. Input: '${textInput}', Has error: ${hasError}`);
      return hasError;
    });
  }
};

--- END: app.js ---

--- START: app.json (sha256=3a9322e23bde64db432e5e448a1c252041d23a666be7fc1765f7bf843a3f20dd, bytes=104005) ---
{
  "id": "no.tiwas.booleantoolbox",
  "support": "https://community.homey.app/t/app-boolean-toolbox-create-advanced-logic-with-simple-formulas/143906",
  "version": "1.2.2",
  "compatibility": ">=5.0.0",
  "sdk": 3,
  "permissions": [
    "homey:manager:api"
  ],
  "name": {
    "en": "Boolean Toolbox",
    "no": "Boolean Toolbox",
    "de": "Boolean Toolbox",
    "nl": "Boolean Toolbox",
    "fr": "Boolean Toolbox",
    "da": "Boolean Toolbox",
    "fi": "Boolean Toolbox",
    "sv": "Boolean Toolbox",
    "pl": "Boolean Toolbox",
    "it": "Boolean Toolbox",
    "es": "Boolean Toolbox"
  },
  "description": {
    "en": "Create advanced, state-aware logic units with multiple formulas.",
    "no": "Lag avanserte, tilstandsbevisste logiske enheter med flere formler.",
    "de": "Erstellen Sie erweiterte, zustandsbewusste Logikeinheiten mit mehreren Formeln.",
    "nl": "Maak geavanceerde, toestandsbewuste logische eenheden met meerdere formules.",
    "fr": "Créez des unités logiques avancées et conscientes de l'état avec plusieurs formules.",
    "da": "Opret avancerede, tilstandsbevidste logiske enheder med flere formler.",
    "fi": "Luo edistyneitä, tilatietoisia logiikkayksiköitä useilla kaavoilla.",
    "sv": "Skapa avancerade, tillståndsmedvetna logikenheter med flera formler.",
    "pl": "Twórz zaawansowane, świadome stanu jednostki logiczne z wieloma formułami.",
    "it": "Crea unità logiche avanzate e consapevoli dello stato con formule multiple.",
    "es": "Crea unidades lógicas avanzadas y conscientes del estado con múltiples fórmulas."
  },
  "category": "tools",
  "brandColor": "#FF0000",
  "author": {
    "name": "Lars Kvanum"
  },
  "contributing": {
    "donate": {
      "paypal": {
        "username": "tiwasno"
      }
    }
  },
  "bugs": {
    "url": "https://github.com/Tiwas/HomeyBooleanToolbox/issues"
  },
  "source": "https://github.com/Tiwas/HomeyBooleanToolbox",
  "homepage": "https://tiwas.github.io/HomeyBooleanToolbox/",
  "images": {
    "xlarge": "/assets/images/xlarge.jpeg",
    "large": "/assets/images/large.jpeg",
    "small": "/assets/images/small.jpeg"
  },
  "drivers": [
    {
      "id": "logic-device",
      "name": {
        "en": "Logic Device",
        "no": "Logisk Enhet",
        "de": "Logikgerät",
        "nl": "Logisch Apparaat",
        "fr": "Appareil Logique",
        "da": "Logisk Enhed",
        "fi": "Logiikkalaite",
        "sv": "Logikenhet",
        "pl": "Urządzenie Logiczne",
        "it": "Dispositivo Logico",
        "es": "Dispositivo Lógico"
      },
      "class": "other",
      "capabilities": [
          "onoff",
          "alarm_generic"
        ],
        "capabilitiesOptions": {
          "alarm_generic": {
            "title": {
              "en": "Logic State",
              "no": "Logikk-status",
              "de": "Logikzustand",
              "nl": "Logische Status",
              "fr": "État Logique",
              "da": "Logisk Status",
              "fi": "Logiikkatila",
              "sv": "Logikstatus",
              "pl": "Stan Logiczny",
              "it": "Stato Logico",
              "es": "Estado Lógico"
            },
            "uiComponent": "sensor",
            "getable": true,
            "setable": false,
            "units": {
              "en": ""
            },
            "icon": "/assets/icon.svg"
          }
        },  
        "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-device/assets/images/large.png",
        "small": "/drivers/logic-device/assets/images/small.png"
      },
      "pair": [
        {
          "id": "select_num_inputs"
        },
        {
          "id": "configure_inputs"
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "type": "group",
          "label": {
            "en": "Formulas",
            "no": "Formler",
            "de": "Formeln",
            "nl": "Formules",
            "fr": "Formules",
            "da": "Formler",
            "fi": "Kaavat",
            "sv": "Formler",
            "pl": "Formuły",
            "it": "Formule",
            "es": "Fórmulas"
          },
          "children": [
            {
              "id": "formulas",
              "type": "textarea",
              "label": {
                "en": "Formulas (JSON)",
                "no": "Formler (JSON)",
                "de": "Formeln (JSON)",
                "nl": "Formules (JSON)",
                "fr": "Formules (JSON)",
                "da": "Formler (JSON)",
                "fi": "Kaavat (JSON)",
                "sv": "Formler (JSON)",
                "pl": "Formuły (JSON)",
                "it": "Formule (JSON)",
                "es": "Fórmulas (JSON)"
              },
              "hint": {
                "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON will be auto-formatted when you save.\n\nExample:\n[{\"id\":\"f1\",\"name\":\"Main Logic\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: false (default) = reactive mode, true/1 = lock inputs at first value",
                "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON vil bli auto-formatert når du lagrer.\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Hovedlogikk\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: false (standard) = reaktiv modus, true/1 = lås inputs ved første verdi",
                "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON wird beim Speichern automatisch formatiert.\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Hauptlogik\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: Sekunden vor Zeitüberschreitung (weglassen/0 = unendlich)\nfirstImpression: false (Standard) = reaktiver Modus, true/1 = Eingänge beim ersten Wert sperren",
                "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON wordt automatisch opgemaakt bij het opslaan.\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Hoofdlogica\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: seconden voor time-out (weglaten/0 = oneindig)\nfirstImpression: false (standaard) = reactieve modus, true/1 = vergrendel invoer bij eerste waarde",
                "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs : AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nLe JSON sera formaté automatiquement lors de l'enregistrement.\n\nExemple :\n[{\"id\":\"f1\",\"name\":\"Logique Principale\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout : secondes avant l'expiration (omettre/0 = infini)\nfirstImpression : false (par défaut) = mode réactif, true/1 = verrouiller les entrées à la première valeur",
                "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON bliver auto-formateret, når du gemmer.\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Hovedlogik\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: false (standard) = reaktiv tilstand, true/1 = lås input ved første værdi",
                "fi": "JSON-taulukko. Jokaisella kaavalla on oma syötetila. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON muotoillaan automaattisesti tallennettaessa.\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Päälogiikka\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: sekuntia ennen aikakatkaisua (jätä pois/0 = ääretön)\nfirstImpression: false (oletus) = reaktiivinen tila, true/1 = lukitse syötteet ensimmäiseen arvoon",
                "sv": "JSON-array. Varje formel har sin egen ingångsstatus. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON kommer att autoformateras när du sparar.\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Huvudlogik\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: false (standard) = reaktivt läge, true/1 = lås ingångar vid första värdet",
                "pl": "Tablica JSON. Każda formuła ma swój własny stan wejściowy. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nJSON zostanie automatycznie sformatowany po zapisaniu.\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Główna Logika\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: sekundy do przekroczenia limitu czasu (pomiń/0 = nieskończony)\nfirstImpression: false (domyślnie) = tryb reaktywny, true/1 = zablokuj wejścia przy pierwszej wartości",
                "it": "Array JSON. Ogni formula ha il proprio stato di input. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nIl JSON verrà formattato automaticamente al salvataggio.\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Logica Principale\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: secondi prima del timeout (omettere/0 = infinito)\nfirstImpression: false (predefinito) = modalità reattiva, true/1 = blocca gli input al primo valore",
                "es": "Array JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEl JSON se formateará automáticamente al guardar.\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Lógica Principal\",\"expression\":\"A AND B AND NOT C\",\"enabled\":true,\"timeout\":30,\"firstImpression\":false}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: false (predeterminado) = modo reactivo, true/1 = bloquear entradas en el primer valor"
              },
              "value": "[]"
            }
          ]
        },
        {
          "type": "group",
          "label": {
            "en": "Input Links",
            "no": "Inngangs-koblinger",
            "de": "Eingangsverknüpfungen",
            "nl": "Invoerkoppelingen",
            "fr": "Liens d'Entrée",
            "da": "Input-links",
            "fi": "Tulolinkit",
            "sv": "Ingångslänkar",
            "pl": "Linki Wejściowe",
            "it": "Collegamenti di Ingresso",
            "es": "Enlaces de Entrada"
          },
          "children": [
            {
              "id": "input_links",
              "type": "textarea",
              "label": {
                "en": "Input Links (JSON)",
                "no": "Inngangs-koblinger (JSON)",
                "de": "Eingangsverknüpfungen (JSON)",
                "nl": "Invoerkoppelingen (JSON)",
                "fr": "Liens d'Entrée (JSON)",
                "da": "Input-links (JSON)",
                "fi": "Tulolinkit (JSON)",
                "sv": "Ingångslänkar (JSON)",
                "pl": "Linki Wejściowe (JSON)",
                "it": "Collegamenti di Ingresso (JSON)",
                "es": "Enlaces de Entrada (JSON)"
              },
              "hint": {
                "en": "Links between inputs and devices. JSON will be auto-formatted when you save.\n\nExample:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Kitchen Light\"}]",
                "no": "Koblinger mellom innganger og enheter. JSON vil bli auto-formatert når du lagrer.\n\nEksempel:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Kjøkkenlys\"}]",
                "de": "Verknüpfungen zwischen Eingängen und Geräten. JSON wird beim Speichern automatisch formatiert.\n\nBeispiel:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Küchenlicht\"}]",
                "nl": "Koppelingen tussen ingangen en apparaten. JSON wordt automatisch opgemaakt bij het opslaan.\n\nVoorbeeld:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Keukenlamp\"}]",
                "fr": "Liens entre les entrées et les appareils. Le JSON sera formaté automatiquement lors de l'enregistrement.\n\nExemple :\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Lumière Cuisine\"}]",
                "da": "Links mellem inputs og enheder. JSON bliver auto-formateret, når du gemmer.\n\nEksempel:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Køkkenlys\"}]",
                "fi": "Linkit syötteiden ja laitteiden välillä. JSON muotoillaan automaattisesti tallennettaessa.\n\nEsimerkki:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Keittiön Valo\"}]",
                "sv": "Länkar mellan ingångar och enheter. JSON kommer att autoformateras när du sparar.\n\nExempel:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Kökslampa\"}]",
                "pl": "Powiązania między wejściami a urządzeniami. JSON zostanie automatycznie sformatowany po zapisaniu.\n\nPrzykład:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Światło w kuchni\"}]",
                "it": "Collegamenti tra input e dispositivi. Il JSON verrà formattato automaticamente al salvataggio.\n\nEsempio:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Luce Cucina\"}]",
                "es": "Enlaces entre entradas y dispositivos. El JSON se formateará automáticamente al guardar.\n\nEjemplo:\n[{\"input\":\"a\",\"deviceId\":\"abc123\",\"capability\":\"onoff\",\"deviceName\":\"Luz de la Cocina\"}]"
              },
              "value": "[]"
            }
          ]
        }
      ]
    },
    {
      "id": "logic-unit-2",
      "name": {
        "en": "Logic Unit (2 inputs)",
        "no": "Logisk Enhet (2 innganger)",
        "de": "Logikeinheit (2 Eingänge)",
        "nl": "Logische Eenheid (2 ingangen)",
        "fr": "Unité Logique (2 entrées)",
        "da": "Logisk Enhed (2 indgange)",
        "fi": "Logiikkayksikkö (2 tuloa)",
        "sv": "Logikenhet (2 ingångar)",
        "pl": "Jednostka Logiczna (2 wejścia)",
        "it": "Unità Logica (2 ingressi)",
        "es": "Unidad Lógica (2 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-2/assets/images/large.png",
        "small": "/drivers/logic-unit-2/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"My Formula\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Meine Formel\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Mijn Formule\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Ma Formule\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Kaavani\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Moja Formuła\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"La Mia Formula\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Mi Fórmula\",\"expression\":\"A AND B\",\"enabled\":true,\"timeout\":30,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-3",
      "name": {
        "en": "Logic Unit (3 inputs)",
        "no": "Logisk Enhet (3 innganger)",
        "de": "Logikeinheit (3 Eingänge)",
        "nl": "Logische Eenheid (3 ingangen)",
        "fr": "Unité Logique (3 entrées)",
        "da": "Logisk Enhed (3 indgange)",
        "fi": "Logiikkayksikkö (3 tuloa)",
        "sv": "Logikenhet (3 ingångar)",
        "pl": "Jednostka Logiczna (3 wejścia)",
        "it": "Unità Logica (3 ingressi)",
        "es": "Unidad Lógica (3 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-3/assets/images/large.png",
        "small": "/drivers/logic-unit-3/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"My Formula\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Meine Formel\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Mijn Formule\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Ma Formule\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Kaavani\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Moja Formuła\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"La Mia Formula\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Mi Fórmula\",\"expression\":\"(A+B)*C\",\"enabled\":true,\"timeout\":60,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-4",
      "name": {
        "en": "Logic Unit (4 inputs)",
        "no": "Logisk Enhet (4 innganger)",
        "de": "Logikeinheit (4 Eingänge)",
        "nl": "Logische Eenheid (4 ingangen)",
        "fr": "Unité Logique (4 entrées)",
        "da": "Logisk Enhed (4 indgange)",
        "fi": "Logiikkayksikkö (4 tuloa)",
        "sv": "Logikenhet (4 ingångar)",
        "pl": "Jednostka Logiczna (4 wejścia)",
        "it": "Unità Logica (4 ingressi)",
        "es": "Unidad Lógica (4 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-4/assets/images/large.png",
        "small": "/drivers/logic-unit-4/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"My Formula\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Meine Formel\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Mijn Formule\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Ma Formule\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Kaavani\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Min Formel\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Moja Formuła\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"La Mia Formula\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Mi Fórmula\",\"expression\":\"(A+B)*(C+D)\",\"enabled\":true,\"timeout\":45,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-5",
      "name": {
        "en": "Logic Unit (5 inputs)",
        "no": "Logisk Enhet (5 innganger)",
        "de": "Logikeinheit (5 Eingänge)",
        "nl": "Logische Eenheid (5 ingangen)",
        "fr": "Unité Logique (5 entrées)",
        "da": "Logisk Enhed (5 indgange)",
        "fi": "Logiikkayksikkö (5 tuloa)",
        "sv": "Logikenhet (5 ingångar)",
        "pl": "Jednostka Logiczna (5 wejść)",
        "it": "Unità Logica (5 ingressi)",
        "es": "Unidad Lógica (5 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-5/assets/images/large.png",
        "small": "/drivers/logic-unit-5/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"All active\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Alle aktive\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Alle aktiv\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Alle actief\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Tous actifs\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Alle aktive\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Kaikki aktiivisia\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Alla aktiva\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Wszystkie aktywne\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Tutti attivi\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Todos activos\",\"expression\":\"A&B&C&D&E\",\"enabled\":true,\"timeout\":120,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-6",
      "name": {
        "en": "Logic Unit (6 inputs)",
        "no": "Logisk Enhet (6 innganger)",
        "de": "Logikeinheit (6 Eingänge)",
        "nl": "Logische Eenheid (6 ingangen)",
        "fr": "Unité Logique (6 entrées)",
        "da": "Logisk Enhed (6 indgange)",
        "fi": "Logiikkayksikkö (6 tuloa)",
        "sv": "Logikenhet (6 ingångar)",
        "pl": "Jednostka Logiczna (6 wejść)",
        "it": "Unità Logica (6 ingressi)",
        "es": "Unidad Lógica (6 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-6/assets/images/large.png",
        "small": "/drivers/logic-unit-6/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"Three groups\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Tre grupper\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Drei Gruppen\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Drie groepen\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Trois groupes\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Tre grupper\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Kolme ryhmää\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Tre grupper\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Trzy grupy\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Tre gruppi\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Tres grupos\",\"expression\":\"(A+B)*(C+D)*(E+F)\",\"enabled\":true,\"timeout\":90,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-7",
      "name": {
        "en": "Logic Unit (7 inputs)",
        "no": "Logisk Enhet (7 innganger)",
        "de": "Logikeinheit (7 Eingänge)",
        "nl": "Logische Eenheid (7 ingangen)",
        "fr": "Unité Logique (7 entrées)",
        "da": "Logisk Enhed (7 indgange)",
        "fi": "Logiikkayksikkö (7 tuloa)",
        "sv": "Logikenhet (7 ingångar)",
        "pl": "Jednostka Logiczna (7 wejść)",
        "it": "Unità Logica (7 ingressi)",
        "es": "Unidad Lógica (7 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-7/assets/images/large.png",
        "small": "/drivers/logic-unit-7/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"Grouped\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Grupperte\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Gruppiert\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Gegroepeerd\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Groupé\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Grupperet\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Ryhmitelty\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Grupperad\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Zgrupowane\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Raggruppato\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Agrupado\",\"expression\":\"(A+B+C)*(D+E)*(F+G)\",\"enabled\":true,\"timeout\":150,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-8",
      "name": {
        "en": "Logic Unit (8 inputs)",
        "no": "Logisk Enhet (8 innganger)",
        "de": "Logikeinheit (8 Eingänge)",
        "nl": "Logische Eenheid (8 ingangen)",
        "fr": "Unité Logique (8 entrées)",
        "da": "Logisk Enhed (8 indgange)",
        "fi": "Logiikkayksikkö (8 tuloa)",
        "sv": "Logikenhet (8 ingångar)",
        "pl": "Jednostka Logiczna (8 wejść)",
        "it": "Unità Logica (8 ingressi)",
        "es": "Unidad Lógica (8 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-8/assets/images/large.png",
        "small": "/drivers/logic-unit-8/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"Four pairs\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Fire par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Vier Paare\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Vier paren\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Quatre paires\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Fire par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Neljä paria\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Fyra par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Cztery pary\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Quattro coppie\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Cuatro pares\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)\",\"enabled\":true,\"timeout\":180,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-9",
      "name": {
        "en": "Logic Unit (9 inputs)",
        "no": "Logisk Enhet (9 innganger)",
        "de": "Logikeinheit (9 Eingänge)",
        "nl": "Logische Eenheid (9 ingangen)",
        "fr": "Unité Logique (9 entrées)",
        "da": "Logisk Enhed (9 indgange)",
        "fi": "Logiikkayksikkö (9 tuloa)",
        "sv": "Logikenhet (9 ingångar)",
        "pl": "Jednostka Logiczna (9 wejść)",
        "it": "Unità Logica (9 ingressi)",
        "es": "Unidad Lógica (9 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-9/assets/images/large.png",
        "small": "/drivers/logic-unit-9/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"Three trios\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Tre trioer\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Drei Trios\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Drie trio's\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Trois trios\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Tre trioer\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Kolme kolmikkoa\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Tre trior\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Trzy trójki\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Tre trii\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Tres tríos\",\"expression\":\"(A+B+C)*(D+E+F)*(G+H+I)\",\"enabled\":true,\"timeout\":200,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    },
    {
      "id": "logic-unit-10",
      "name": {
        "en": "Logic Unit (10 inputs)",
        "no": "Logisk Enhet (10 innganger)",
        "de": "Logikeinheit (10 Eingänge)",
        "nl": "Logische Eenheid (10 ingangen)",
        "fr": "Unité Logique (10 entrées)",
        "da": "Logisk Enhed (10 indgange)",
        "fi": "Logiikkayksikkö (10 tuloa)",
        "sv": "Logikenhet (10 ingångar)",
        "pl": "Jednostka Logiczna (10 wejść)",
        "it": "Unità Logica (10 ingressi)",
        "es": "Unidad Lógica (10 entradas)"
      },
      "class": "other",
      "capabilities": [
        "onoff"
      ],
      "energy": {
        "approximation": {
          "usageConstant": 0
        }
      },
      "images": {
        "large": "/drivers/logic-unit-10/assets/images/large.png",
        "small": "/drivers/logic-unit-10/assets/images/small.png"
      },
      "pair": [
        {
          "id": "list_devices",
          "template": "list_devices",
          "navigation": {
            "next": "add_devices"
          }
        },
        {
          "id": "add_devices",
          "template": "add_devices"
        }
      ],
      "settings": [
        {
          "id": "formulas",
          "type": "textarea",
          "label": {
            "en": "Formulas (JSON)",
            "no": "Formler (JSON)",
            "de": "Formeln (JSON)",
            "nl": "Formules (JSON)",
            "fr": "Formules (JSON)",
            "da": "Formler (JSON)",
            "fi": "Kaavat (JSON)",
            "sv": "Formler (JSON)",
            "pl": "Formuły (JSON)",
            "it": "Formule (JSON)",
            "es": "Fórmulas (JSON)"
          },
          "hint": {
            "en": "JSON array. Each formula has its own input state. Operators: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExample:\n[{\"id\":\"f1\",\"name\":\"Five pairs\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: seconds before timeout (omit/0 = infinite)\nfirstImpression: true/1 (default) = lock inputs at first value, false/0 = reactive mode",
            "no": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Fem par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (utelat/0 = uendelig)\nfirstImpression: true/1 (standard) = lås inputs ved første verdi, false/0 = reaktiv modus",
            "de": "JSON-Array. Jede Formel hat ihren eigenen Eingangszustand. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nBeispiel:\n[{\"id\":\"f1\",\"name\":\"Fünf Paare\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: Sekunden vor Timeout (weglassen/0 = unendlich)\nfirstImpression: true/1 (Standard) = Eingänge beim ersten Wert sperren, false/0 = reaktiver Modus",
            "nl": "JSON-array. Elke formule heeft zijn eigen invoerstatus. Operatoren: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nVoorbeeld:\n[{\"id\":\"f1\",\"name\":\"Vijf paren\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: seconden voor timeout (weglaten/0 = oneindig)\nfirstImpression: true/1 (standaard) = invoer vergrendelen bij eerste waarde, false/0 = reactieve modus",
            "fr": "Tableau JSON. Chaque formule a son propre état d'entrée. Opérateurs: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExemple:\n[{\"id\":\"f1\",\"name\":\"Cinq paires\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: secondes avant expiration (omettre/0 = infini)\nfirstImpression: true/1 (défaut) = verrouiller les entrées à la première valeur, false/0 = mode réactif",
            "da": "JSON-array. Hver formel har sin egen input-tilstand. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEksempel:\n[{\"id\":\"f1\",\"name\":\"Fem par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: sekunder før timeout (udelad/0 = uendelig)\nfirstImpression: true/1 (standard) = lås input ved første værdi, false/0 = reaktiv tilstand",
            "fi": "JSON-taulukko. Jokaisella kaavalla on oma tulotilaansa. Operaattorit: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsimerkki:\n[{\"id\":\"f1\",\"name\":\"Viisi paria\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: sekuntia ennen aikakatkaistua (jätä pois/0 = ääretön)\nfirstImpression: true/1 (oletus) = lukitse tulot ensimmäiseen arvoon, false/0 = reaktiivinen tila",
            "sv": "JSON-array. Varje formel har sitt eget ingångstillstånd. Operatorer: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nExempel:\n[{\"id\":\"f1\",\"name\":\"Fem par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: sekunder före timeout (utelämna/0 = oändlig)\nfirstImpression: true/1 (standard) = lås ingångar vid första värdet, false/0 = reaktivt läge",
            "pl": "Tablica JSON. Każda formuła ma swój własny stan wejścia. Operatory: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nPrzykład:\n[{\"id\":\"f1\",\"name\":\"Pięć par\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: sekundy przed przekroczeniem czasu (pomiń/0 = nieskończony)\nfirstImpression: true/1 (domyślnie) = zablokuj wejścia przy pierwszej wartości, false/0 = tryb reaktywny",
            "it": "Array JSON. Ogni formula ha il proprio stato di ingresso. Operatori: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEsempio:\n[{\"id\":\"f1\",\"name\":\"Cinque coppie\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: secondi prima del timeout (ometti/0 = infinito)\nfirstImpression: true/1 (predefinito) = blocca ingressi al primo valore, false/0 = modalità reattiva",
            "es": "Matriz JSON. Cada fórmula tiene su propio estado de entrada. Operadores: AND(*,&), OR(+,|), XOR(^,!=), NOT(!).\n\nEjemplo:\n[{\"id\":\"f1\",\"name\":\"Cinco pares\",\"expression\":\"(A+B)*(C+D)*(E+F)*(G+H)*(I+J)\",\"enabled\":true,\"timeout\":240,\"firstImpression\":true}]\n\ntimeout: segundos antes del tiempo de espera (omitir/0 = infinito)\nfirstImpression: true/1 (predeterminado) = bloquear entradas en el primer valor, false/0 = modo reactivo"
          },
          "value": "[]"
        }
      ]
    }
  ],
  "flow": {
    "triggers": [
      {
        "id": "formula_changed_to_true",
        "title": {
          "en": "Formula result changed to TRUE",
          "no": "Formelresultat ble SANN",
          "de": "Formelergebnis wurde WAHR",
          "nl": "Formule resultaat werd WAAR",
          "fr": "Le résultat de la formule est devenu VRAI",
          "da": "Formelresultat blev SAND",
          "fi": "Kaavan tulos muuttui TODEKSI",
          "sv": "Formelresultat blev SANT",
          "pl": "Wynik formuły zmienił się na PRAWDA",
          "it": "Il risultato della formula è diventato VERO",
          "es": "El resultado de la fórmula cambió a VERDADERO"
        },
        "titleFormatted": {
          "en": "Formula [[formula]] changed to TRUE",
          "no": "Formel [[formula]] ble SANN",
          "de": "Formel [[formula]] wurde WAHR",
          "nl": "Formule [[formula]] werd WAAR",
          "fr": "La formule [[formula]] est devenue VRAI",
          "da": "Formel [[formula]] blev SAND",
          "fi": "Kaava [[formula]] muuttui TODEKSI",
          "sv": "Formel [[formula]] blev SANT",
          "pl": "Formuła [[formula]] zmieniła się na PRAWDA",
          "it": "La formula [[formula]] è diventata VERO",
          "es": "La fórmula [[formula]] cambió a VERDADERO"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          }
        ]
      },
      {
        "id": "formula_changed_to_false",
        "title": {
          "en": "Formula result changed to FALSE",
          "no": "Formelresultat ble USANN",
          "de": "Formelergebnis wurde FALSCH",
          "nl": "Formule resultaat werd ONWAAR",
          "fr": "Le résultat de la formule est devenu FAUX",
          "da": "Formelresultat blev FALSK",
          "fi": "Kaavan tulos muuttui EPÄTODEKSI",
          "sv": "Formelresultat blev FALSKT",
          "pl": "Wynik formuły zmienił się na FAŁSZ",
          "it": "Il risultato della formula è diventato FALSO",
          "es": "El resultado de la fórmula cambió a FALSO"
        },
        "titleFormatted": {
          "en": "Formula [[formula]] changed to FALSE",
          "no": "Formel [[formula]] ble USANN",
          "de": "Formel [[formula]] wurde FALSCH",
          "nl": "Formule [[formula]] werd ONWAAR",
          "fr": "La formule [[formula]] est devenue FAUX",
          "da": "Formel [[formula]] blev FALSK",
          "fi": "Kaava [[formula]] muuttui EPÄTODEKSI",
          "sv": "Formel [[formula]] blev FALSKT",
          "pl": "Formuła [[formula]] zmieniła się na FAŁSZ",
          "it": "La formula [[formula]] è diventata FALSO",
          "es": "La fórmula [[formula]] cambió a FALSO"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          }
        ]
      },
      {
        "id": "formula_timeout",
        "title": {
          "en": "Formula timed out",
          "no": "Formel fikk timeout",
          "de": "Formel Zeitüberschreitung",
          "nl": "Formule time-out",
          "fr": "La formule a expiré",
          "da": "Formel fik timeout",
          "fi": "Kaava aikakatkaistiin",
          "sv": "Formel fick timeout",
          "pl": "Formuła przekroczyła czas",
          "it": "Formula scaduta",
          "es": "La fórmula agotó el tiempo"
        },
        "titleFormatted": {
          "en": "Formula [[formula]] timed out",
          "no": "Formel [[formula]] fikk timeout",
          "de": "Formel [[formula]] Zeitüberschreitung",
          "nl": "Formule [[formula]] time-out",
          "fr": "La formule [[formula]] a expiré",
          "da": "Formel [[formula]] fik timeout",
          "fi": "Kaava [[formula]] aikakatkaistiin",
          "sv": "Formel [[formula]] fick timeout",
          "pl": "Formuła [[formula]] przekroczyła czas",
          "it": "Formula [[formula]] scaduta",
          "es": "La fórmula [[formula]] agotó el tiempo"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          }
        ]
      },
      {
        "id": "device_state_changed",
        "title": {
          "en": "State changed",
          "no": "Tilstand endret",
          "de": "Zustand geändert",
          "nl": "Staat gewijzigd",
          "fr": "État modifié",
          "da": "Tilstand ændret",
          "fi": "Tila muuttunut",
          "sv": "Tillstånd ändrat",
          "pl": "Stan zmieniony",
          "it": "Stato cambiato",
          "es": "Estado cambiado"
        },
        "hint": {
          "en": "Triggers when the device state changes (on/off)",
          "no": "Trigges når enhetens tilstand endres (på/av)",
          "de": "Wird ausgelöst, wenn sich der Gerätestatus ändert (ein/aus)",
          "nl": "Activeert wanneer de apparaatstatus verandert (aan/uit)",
          "fr": "Se déclenche lorsque l'état de l'appareil change (marche/arrêt)",
          "da": "Udløses, når enhedens tilstand ændres (tænd/sluk)",
          "fi": "Laukaistaan, kun laitteen tila muuttuu (päälle/pois)",
          "sv": "Utlöses när enhetens tillstånd ändras (på/av)",
          "pl": "Uruchamia się, gdy stan urządzenia ulegnie zmianie (włącz/wyłącz)",
          "it": "Si attiva quando lo stato del dispositivo cambia (on/off)",
          "es": "Se activa cuando el estado del dispositivo cambia (encendido/apagado)"
        },
        "tokens": [
          {
            "name": "state",
            "type": "boolean",
            "title": {
              "en": "State",
              "no": "Tilstand",
              "de": "Zustand",
              "nl": "Staat",
              "fr": "État",
              "da": "Tilstand",
              "fi": "Tila",
              "sv": "Tillstånd",
              "pl": "Stan",
              "it": "Stato",
              "es": "Estado"
            },
            "example": true
          }
        ],
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-device"
          }
        ]
      }      
    ],
    "actions": [
      {
        "id": "set_input_value",
        "title": {
          "en": "Set input value for formula",
          "no": "Sett inngangsverdi for formel",
          "de": "Eingangswert für Formel festlegen",
          "nl": "Stel invoerwaarde in voor formule",
          "fr": "Définir la valeur d'entrée pour la formule",
          "da": "Indstil inputværdi for formel",
          "fi": "Aseta tuloarvo kaavalle",
          "sv": "Ställ in ingångsvärde för formel",
          "pl": "Ustaw wartość wejścia dla formuły",
          "it": "Imposta valore di ingresso per formula",
          "es": "Establecer valor de entrada para fórmula"
        },
        "titleFormatted": {
          "en": "Set [[input]] to [[value]] for [[formula]]",
          "no": "Sett [[input]] til [[value]] for [[formula]]",
          "de": "[[input]] auf [[value]] für [[formula]] setzen",
          "nl": "Stel [[input]] in op [[value]] voor [[formula]]",
          "fr": "Définir [[input]] à [[value]] pour [[formula]]",
          "da": "Sæt [[input]] til [[value]] for [[formula]]",
          "fi": "Aseta [[input]] arvoon [[value]] kaavalle [[formula]]",
          "sv": "Ställ in [[input]] till [[value]] för [[formula]]",
          "pl": "Ustaw [[input]] na [[value]] dla [[formula]]",
          "it": "Imposta [[input]] a [[value]] per [[formula]]",
          "es": "Establecer [[input]] en [[value]] para [[formula]]"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          },
          {
            "type": "autocomplete",
            "name": "input",
            "placeholder": {
              "en": "Select Input",
              "no": "Velg Inngang",
              "de": "Eingang wählen",
              "nl": "Kies Ingang",
              "fr": "Sélectionner une Entrée",
              "da": "Vælg Input",
              "fi": "Valitse Tulo",
              "sv": "Välj Ingång",
              "pl": "Wybierz Wejście",
              "it": "Seleziona Ingresso",
              "es": "Seleccionar Entrada"
            }
          },
          {
            "name": "value",
            "type": "dropdown",
            "values": [
              {
                "id": "true",
                "label": {
                  "en": "true",
                  "no": "sann",
                  "de": "wahr",
                  "nl": "waar",
                  "fr": "vrai",
                  "da": "sand",
                  "fi": "tosi",
                  "sv": "sant",
                  "pl": "prawda",
                  "it": "vero",
                  "es": "verdadero"
                }
              },
              {
                "id": "false",
                "label": {
                  "en": "false",
                  "no": "usann",
                  "de": "falsch",
                  "nl": "onwaar",
                  "fr": "faux",
                  "da": "falsk",
                  "fi": "epätosi",
                  "sv": "falskt",
                  "pl": "fałsz",
                  "it": "falso",
                  "es": "falso"
                }
              }
            ]
          }
        ]
      },
      {
        "id": "evaluate_formula",
        "title": {
          "en": "Evaluate formula",
          "no": "Evaluer formel",
          "de": "Formel auswerten",
          "nl": "Evalueer formule",
          "fr": "Évaluer la formule",
          "da": "Evaluer formel",
          "fi": "Arvioi kaava",
          "sv": "Utvärdera formel",
          "pl": "Oceń formułę",
          "it": "Valuta formula",
          "es": "Evaluar fórmula"
        },
        "titleFormatted": {
          "en": "Evaluate [[formula]]",
          "no": "Evaluer [[formula]]",
          "de": "[[formula]] auswerten",
          "nl": "Evalueer [[formula]]",
          "fr": "Évaluer [[formula]]",
          "da": "Evaluer [[formula]]",
          "fi": "Arvioi [[formula]]",
          "sv": "Utvärdera [[formula]]",
          "pl": "Oceń [[formula]]",
          "it": "Valuta [[formula]]",
          "es": "Evaluar [[formula]]"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          }
        ]
      },
      {
        "id": "evaluate_all_formulas",
        "title": {
          "en": "Re-evaluate all formulas",
          "no": "Re-evaluer alle formler",
          "de": "Alle Formeln neu auswerten",
          "nl": "Herevalueer alle formules",
          "fr": "Réévaluer toutes les formules",
          "da": "Genberegn alle formler",
          "fi": "Arvioi kaikki kaavat uudelleen",
          "sv": "Omvärdera alla formler",
          "pl": "Oceń ponownie wszystkie formuły",
          "it": "Rivaluta tutte le formule",
          "es": "Reevaluar todas las fórmulas"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          }
        ]
      },
      {
        "id": "evaluate_expression",
        "title": {
          "en": "Evaluate expression",
          "no": "Evaluer uttrykk",
          "de": "Ausdruck auswerten",
          "nl": "Expressie evalueren",
          "fr": "Évaluer l'expression",
          "da": "Evaluer udtryk",
          "fi": "Arvioi lauseke",
          "sv": "Utvärdera uttryck",
          "pl": "Oceń wyrażenie",
          "it": "Valuta espressione",
          "es": "Evaluar expresión"
        },
        "hint": {
          "en": "Example for rules: 0,10,1;10,20,2;20,30,3",
          "no": "Eksempel for regler: 0,10,1;10,20,2;20,30,3",
          "de": "Beispiel für Regeln: 0,10,1;10,20,2;20,30,3",
          "nl": "Voorbeeld voor regels: 0,10,1;10,20,2;20,30,3",
          "fr": "Exemple pour les règles: 0,10,1;10,20,2;20,30,3",
          "da": "Eksempel for regler: 0,10,1;10,20,2;20,30,3",
          "fi": "Esimerkki säännöille: 0,10,1;10,20,2;20,30,3",
          "sv": "Exempel för regler: 0,10,1;10,20,2;20,30,3",
          "pl": "Przykład dla zasad: 0,10,1;10,20,2;20,30,3",
          "it": "Esempio per le regole: 0,10,1;10,20,2;20,30,3",
          "es": "Ejemplo de reglas: 0,10,1;10,20,2;20,30,3"
        },
        "titleFormatted": {
            "en": "Evaluate [[input]] with rules `[[rules]]` (op1: [[op1]], op2: [[op2]], logic: [[logical_op]])",
            "no": "Evaluer [[input]] med regler `[[rules]]` (op1: [[op1]], op2: [[op2]], logikk: [[logical_op]])",
            "de": "Werte [[input]] mit Regeln `[[rules]]` aus (op1: [[op1]], op2: [[op2]], Logik: [[logical_op]])",
            "nl": "Evalueer [[input]] met regels `[[rules]]` (op1: [[op1]], op2: [[op2]], logica: [[logical_op]])",
            "fr": "Évaluer [[input]] avec les règles `[[rules]]` (op1: [[op1]], op2: [[op2]], logique: [[logical_op]])",
            "da": "Evaluer [[input]] med regler `[[rules]]` (op1: [[op1]], op2: [[op2]], logik: [[logical_op]])",
            "fi": "Arvioi [[input]] säännöillä `[[rules]]` (op1: [[op1]], op2: [[op2]], logiikka: [[logical_op]])",
            "sv": "Utvärdera [[input]] med regler `[[rules]]` (op1: [[op1]], op2: [[op2]], logik: [[logical_op]])",
            "pl": "Oceń [[input]] według zasad `[[rules]]` (op1: [[op1]], op2: [[op2]], logika: [[logical_op]])",
            "it": "Valuta [[input]] con le regole `[[rules]]` (op1: [[op1]], op2: [[op2]], logica: [[logical_op]])",
            "es": "Evaluar [[input]] con reglas `[[rules]]` (op1: [[op1]], op2: [[op2]], lógica: [[logical_op]])"
        },
        "args": [
          {
            "name": "input",
            "type": "number",
            "title": {
              "en": "Input value",
              "no": "Inngangsverdi",
              "de": "Eingabewert",
              "nl": "Invoerwaarde",
              "fr": "Valeur d'entrée",
              "da": "Indtastningsværdi",
              "fi": "Syöttöarvo",
              "sv": "Inmatningsvärde",
              "pl": "Wartość wejściowa",
              "it": "Valore di input",
              "es": "Valor de entrada"
            }
          },
          {
            "name": "rules",
            "type": "text",
            "title": {
                "en": "Rule string (min,max,output;...)",
                "no": "Regel-streng (min,maks,utgang;...)",
                "de": "Regel-Zeichenfolge (min,max,ausgabe;...)",
                "nl": "Regel-string (min,max,uitvoer;...)",
                "fr": "Chaîne de règles (min,max,sortie;...)",
                "da": "Regel-streng (min,max,output;...)",
                "fi": "Sääntö-merkkijono (min,max,ulos;...)",
                "sv": "Regel-sträng (min,max,utdata;...)",
                "pl": "Ciąg reguł (min,maks,wyjście;...)",
                "it": "Stringa regola (min,max,output;...)",
                "es": "Cadena de reglas (mín,máx,salida;...)"
            },
            "placeholder": "e.g. 0,10,1;10,20,2"
          },
          {
            "name": "op1",
            "type": "dropdown",
            "title": {
              "en": "Operator 1 (for min value)",
              "no": "Operator 1 (for min-verdi)",
              "de": "Operator 1 (für Mindestwert)",
              "nl": "Operator 1 (voor min waarde)",
              "fr": "Opérateur 1 (pour valeur min)",
              "da": "Operator 1 (for min-værdi)",
              "fi": "Operaattori 1 (min-arvolle)",
              "sv": "Operator 1 (för min-värde)",
              "pl": "Operator 1 (dla wartości min)",
              "it": "Operatore 1 (per valore min)",
              "es": "Operador 1 (para valor mín)"
            },
            "values": [
              { "id": "gt", "label": { "en": "is greater than (>)", "no": "er større enn (>)", "de": "ist größer als (>)", "nl": "is groter dan (>)", "fr": "est supérieur à (>)", "da": "er større end (>)", "fi": "on suurempi kuin (>)", "sv": "är större än (>)", "pl": "jest większy niż (>)", "it": "è maggiore di (>)", "es": "es mayor que (>)" } },
              { "id": "gte", "label": { "en": "is greater than or equal to (>=)", "no": "er større enn eller lik (>=)", "de": "ist größer oder gleich (>=)", "nl": "is groter dan of gelijk aan (>=)", "fr": "est supérieur ou égal à (>=)", "da": "er større end eller lig med (>=)", "fi": "on suurempi tai yhtä suuri kuin (>=)", "sv": "är större än eller lika med (>=)", "pl": "jest większy lub równy (>=)", "it": "è maggiore o uguale a (>=)", "es": "es mayor o igual que (>=)" } }
            ]
          },
          {
            "name": "op2",
            "type": "dropdown",
            "title": {
              "en": "Operator 2 (for max value)",
              "no": "Operator 2 (for maks-verdi)",
              "de": "Operator 2 (für Höchstwert)",
              "nl": "Operator 2 (voor max waarde)",
              "fr": "Opérateur 2 (pour valeur max)",
              "da": "Operator 2 (for max-værdi)",
              "fi": "Operaattori 2 (max-arvolle)",
              "sv": "Operator 2 (för max-värde)",
              "pl": "Operator 2 (dla wartości max)",
              "it": "Operatore 2 (per valore max)",
              "es": "Operador 2 (para valor máx)"
            },
            "values": [
                { "id": "lt", "label": { "en": "is less than (<)", "no": "er mindre enn (<)", "de": "ist kleiner als (<)", "nl": "is kleiner dan (<)", "fr": "est inférieur à (<)", "da": "er mindre end (<)", "fi": "on pienempi kuin (<)", "sv": "är mindre än (<)", "pl": "jest mniejszy niż (<)", "it": "è minore di (<)", "es": "es menor que (<)" } },
                { "id": "lte", "label": { "en": "is less than or equal to (<=)", "no": "er mindre enn eller lik (<=)", "de": "ist kleiner oder gleich (<=)", "nl": "is kleiner dan of gelijk aan (<=)", "fr": "est inférieur ou égal à (<=)", "da": "er mindre end eller lig med (<=)", "fi": "on pienempi tai yhtä suuri kuin (<=)", "sv": "är mindre än eller lika med (<=)", "pl": "jest mniejszy lub równy (<=)", "it": "è minore o uguale a (<=)", "es": "es menor o igual que (<=)" } }
            ]
          },
          {
            "name": "logical_op",
            "type": "dropdown",
            "title": {
              "en": "Logical operator",
              "no": "Logisk operator",
              "de": "Logischer Operator",
              "nl": "Logische operator",
              "fr": "Opérateur logique",
              "da": "Logisk operator",
              "fi": "Looginen operaattori",
              "sv": "Logisk operator",
              "pl": "Operator logiczny",
              "it": "Operatore logico",
              "es": "Operador lógico"
            },
            "values": [
              { "id": "AND", "label": { "en": "AND", "no": "OG", "de": "UND", "nl": "EN", "fr": "ET", "da": "OG", "fi": "JA", "sv": "OCH", "pl": "I", "it": "E", "es": "Y" } },
              { "id": "OR", "label": { "en": "OR", "no": "ELLER", "de": "ODER", "nl": "OF", "fr": "OU", "da": "ELLER", "fi": "TAI", "sv": "ELLER", "pl": "LUB", "it": "O", "es": "O" } }
            ]
          }
        ],
        "tokens": [
          {
            "name": "outputValue",
            "type": "number",
            "title": { "en": "Result", "no": "Resultat", "de": "Ergebnis", "nl": "Resultaat", "fr": "Résultat", "da": "Resultat", "fi": "Tulos", "sv": "Resultat", "pl": "Wynik", "it": "Risultato", "es": "Resultado" }
          },
          {
            "name": "errorMessage",
            "type": "string",
            "title": { "en": "Error message", "no": "Feilmelding", "de": "Fehlermeldung", "nl": "Foutbericht", "fr": "Message d'erreur", "da": "Fejlmeddelelse", "fi": "Virheilmoitus", "sv": "Felmeddelande", "pl": "Komunikat o błędzie", "it": "Messaggio di errore", "es": "Mensaje de error" }
          }
        ]
      }
    ],
    "conditions": [
      {
        "id": "formula_result_is",
        "title": {
          "en": "Formula result is...",
          "no": "Formelresultat er...",
          "de": "Formelergebnis ist...",
          "nl": "Formule resultaat is...",
          "fr": "Le résultat de la formule est...",
          "da": "Formelresultat er...",
          "fi": "Kaavan tulos on...",
          "sv": "Formelresultat är...",
          "pl": "Wynik formuły to...",
          "it": "Il risultato della formula è...",
          "es": "El resultado de la fórmula es..."
        },
        "titleFormatted": {
          "en": "Formula [[formula]] is [[what_is]]",
          "no": "Formel [[formula]] er [[what_is]]",
          "de": "Formel [[formula]] ist [[what_is]]",
          "nl": "Formule [[formula]] is [[what_is]]",
          "fr": "La formule [[formula]] est [[what_is]]",
          "da": "Formel [[formula]] er [[what_is]]",
          "fi": "Kaava [[formula]] on [[what_is]]",
          "sv": "Formel [[formula]] är [[what_is]]",
          "pl": "Formuła [[formula]] to [[what_is]]",
          "it": "La formula [[formula]] è [[what_is]]",
          "es": "La fórmula [[formula]] es [[what_is]]"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          },
          {
            "name": "what_is",
            "type": "dropdown",
            "values": [
              {
                "id": "true",
                "label": {
                  "en": "true",
                  "no": "sann",
                  "de": "wahr",
                  "nl": "waar",
                  "fr": "vrai",
                  "da": "sand",
                  "fi": "tosi",
                  "sv": "sant",
                  "pl": "prawda",
                  "it": "vero",
                  "es": "verdadero"
                }
              },
              {
                "id": "false",
                "label": {
                  "en": "false",
                  "no": "usann",
                  "de": "falsch",
                  "nl": "onwaar",
                  "fr": "faux",
                  "da": "falsk",
                  "fi": "epätosi",
                  "sv": "falskt",
                  "pl": "fałsz",
                  "it": "falso",
                  "es": "falso"
                }
              }
            ]
          }
        ]
      },
      {
        "id": "formula_has_timed_out",
        "title": {
          "en": "Formula has timed out",
          "no": "Formel har fått timeout",
          "de": "Formel hat Zeitüberschreitung",
          "nl": "Formule heeft time-out",
          "fr": "La formule a expiré",
          "da": "Formel har fået timeout",
          "fi": "Kaava on aikakatkaistu",
          "sv": "Formel har fått timeout",
          "pl": "Formuła przekroczyła czas",
          "it": "La formula è scaduta",
          "es": "La fórmula ha agotado el tiempo"
        },
        "titleFormatted": {
          "en": "Formula [[formula]] has timed out",
          "no": "Formel [[formula]] har fått timeout",
          "de": "Formel [[formula]] hat Zeitüberschreitung",
          "nl": "Formule [[formula]] heeft time-out",
          "fr": "La formule [[formula]] a expiré",
          "da": "Formel [[formula]] har fået timeout",
          "fi": "Kaava [[formula]] on aikakatkaistu",
          "sv": "Formel [[formula]] har fått timeout",
          "pl": "Formuła [[formula]] przekroczyła czas",
          "it": "La formula [[formula]] è scaduta",
          "es": "La fórmula [[formula]] ha agotado el tiempo"
        },
        "args": [
          {
            "type": "device",
            "name": "device",
            "filter": "driver_id=logic-unit-2|logic-unit-3|logic-unit-4|logic-unit-5|logic-unit-6|logic-unit-7|logic-unit-8|logic-unit-9|logic-unit-10"
          },
          {
            "type": "autocomplete",
            "name": "formula",
            "placeholder": {
              "en": "Select Formula",
              "no": "Velg Formel",
              "de": "Formel wählen",
              "nl": "Kies Formule",
              "fr": "Sélectionner une Formule",
              "da": "Vælg Formel",
              "fi": "Valitse Kaava",
              "sv": "Välj Formel",
              "pl": "Wybierz Formułę",
              "it": "Seleziona Formula",
              "es": "Seleccionar Fórmula"
            }
          }
        ]
      },
      {
  "id": "has_error",
  "title": {
    "en": "Has error message",
    "no": "Har feilmelding",
    "de": "Hat Fehlermeldung",
    "nl": "Heeft foutbericht",
    "fr": "A un message d'erreur",
    "da": "Har fejlmeddelelse",
    "fi": "Sisältää virheilmoituksen",
    "sv": "Har felmeddelande",
    "pl": "Posiada komunikat o błędzie",
    "it": "Ha un messaggio di errore",
    "es": "Tiene mensaje de error"
  },
  "titleFormatted": {
    "en": "[[text_input]] has a value",
    "no": "[[text_input]] har en verdi",
    "de": "[[text_input]] hat einen Wert",
    "nl": "[[text_input]] heeft een waarde",
    "fr": "[[text_input]] a une valeur",
    "da": "[[text_input]] har en værdi",
    "fi": "[[text_input]] on arvo",
    "sv": "[[text_input]] har ett värde",
    "pl": "[[text_input]] ma wartość",
    "it": "[[text_input]] ha un valore",
    "es": "[[text_input]] tiene un valor"
  },
  "args": [
    {
      "name": "text_input",
      "type": "text",
      "title": {
        "en": "Error message token",
        "no": "Feilmelding-tag",
        "de": "Fehlermeldungs-Token",
        "nl": "Foutbericht-token",
        "fr": "Jeton du message d'erreur",
        "da": "Fejlmeddelelses-tag",
        "fi": "Virheilmoitus-tunniste",
        "sv": "Felmeddelande-tagg",
        "pl": "Token komunikatu o błędzie",
        "it": "Token del messaggio di errore",
        "es": "Token de mensaje de error"
      }
    }
  ]
}
    ]
  }
}

--- END: app.json ---

--- START: drivers/logic-device/device.js (sha256=793ae0ccd5f9c92fdf7d1291d4f7838a0a45939d93f14f18ab5ce9a859859ba2, bytes=38301) ---
'use strict';

const Homey = require('homey');

module.exports = class LogicDeviceDevice extends Homey.Device {

  async onInit() {
    this.log(`Logic Device '${this.getName()}' initializing.`);
    
    // First, read settings to detect how many inputs we actually need
    const settings = this.getSettings();
    const detectedInputs = this.detectRequiredInputs(settings);
    
    // Use the higher of: detected inputs, or original numInputs from device data
    const originalNumInputs = this.getData().numInputs || 2;
    this.numInputs = Math.max(detectedInputs, originalNumInputs);
    
    if (detectedInputs > originalNumInputs) {
      this.log(`📈 Detected ${detectedInputs} inputs needed (originally ${originalNumInputs}). Expanding capacity!`);
    }
    
    this.availableInputs = this.getAvailableInputIds();
    this.deviceListeners = new Map();
    this.pollingIntervals = new Map();
    
    if (!this.hasCapability('onoff')) {
      await this.addCapability('onoff');
    }
    
    if (!this.hasCapability('alarm_generic')) {
      await this.addCapability('alarm_generic');
    }
    
    try {
      await this.setCapabilityOptions('onoff', {
        setable: false,
        getable: true
      });
      this.log('✅ Set onoff as read-only');
    } catch (e) {
      this.log('Could not set capability options:', e.message);
    }
    
    await this.initializeFormulas();
    await this.setupDeviceLinks();
    
    this.log('Running initial formula evaluation...');
    await this.evaluateAllFormulasInitial();
    
    this.startTimeoutChecks();
    
    this.log(`Logic Device '${this.getName()}' initialized with ${this.numInputs} inputs`);
  }

  getAvailableInputIds() {
    const allInputs = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
    return allInputs.slice(0, this.numInputs);
  }

  getAvailableInputsUppercase() {
    return this.availableInputs.map(i => i.toUpperCase());
  }

  detectRequiredInputs(settings) {
    let maxInput = 2; // Default minimum
    
    try {
      // Check formulas for used inputs
      const formulasData = settings.formulas ? JSON.parse(settings.formulas) : [];
      
      formulasData.forEach(formula => {
        if (!formula.expression) return;
        
        // Find all letter inputs (A-J) in the expression
        const pattern = /\b([A-J])\b/gi;
        const matches = formula.expression.match(pattern);
        
        if (matches) {
          matches.forEach(letter => {
            const inputNumber = letter.toUpperCase().charCodeAt(0) - 64; // A=1, B=2, etc.
            maxInput = Math.max(maxInput, inputNumber);
          });
        }
      });
      
      // Also check input_links
      const inputLinks = settings.input_links ? JSON.parse(settings.input_links) : [];
      
      inputLinks.forEach(link => {
        if (link.input) {
          const inputNumber = link.input.toLowerCase().charCodeAt(0) - 96; // a=1, b=2, etc.
          maxInput = Math.max(maxInput, inputNumber);
        }
      });
      
      this.log(`🔍 Detected max input: ${String.fromCharCode(64 + maxInput)} (${maxInput} inputs needed)`);
      
    } catch (e) {
      this.error('Error detecting required inputs:', e.message);
    }
    
    return maxInput;
  }

  async initializeFormulas() {
    const settings = this.getSettings();
    try {
      const formulasData = settings.formulas ? JSON.parse(settings.formulas) : [];
      
      this.formulas = formulasData.map(f => ({
        id: f.id,
        name: f.name,
        expression: f.expression,
        enabled: f.enabled !== false,
        timeout: f.timeout || 0,
        firstImpression: f.firstImpression === true,
        inputStates: {},
        lockedInputs: {},
        lastInputTime: null,
        result: null,
        timedOut: false
      }));
      
      this.formulas.forEach(formula => {
        this.availableInputs.forEach(id => {
          formula.inputStates[id] = 'undefined';
          formula.lockedInputs[id] = false;
        });
      });
      
    } catch (e) {
      this.error('Failed to parse formulas:', e);
      this.formulas = [];
    }
    
    if (this.formulas.length === 0) {
      const defaultFormula = {
        id: 'formula_1',
        name: 'Main Formula',
        expression: this.getDefaultExpression(),
        enabled: true,
        timeout: 0,
        firstImpression: false,
        inputStates: {},
        lockedInputs: {},
        lastInputTime: null,
        result: null,
        timedOut: false
      };
      
      this.availableInputs.forEach(id => {
        defaultFormula.inputStates[id] = 'undefined';
        defaultFormula.lockedInputs[id] = false;
      });
      
      this.formulas = [defaultFormula];
    }
    
    this.log(`Initialized ${this.formulas.length} formulas`);
    this.formulas.forEach(f => {
      this.log(`  - ${f.name}: "${f.expression}" (enabled: ${f.enabled})`);
    });
  }

  getDefaultExpression() {
    const inputs = this.getAvailableInputsUppercase();
    return inputs.join(' AND ');
  }

  async setupDeviceLinks() {
    this.log('Setting up device links...');

    // Rydd opp eventuelle gamle lyttere
    for (const [key, listener] of this.deviceListeners.entries()) {
      try {
        if (listener.unregister) {
          await listener.unregister();
          this.log(`Unregistered listener: ${key}`);
        }
      } catch (e) {
        this.error('Error unregistering listener:', e);
      }
    }
    this.deviceListeners.clear();

    // Les koblinger fra settings
    const settings = this.getSettings();
    let inputLinks = [];
    try {
      inputLinks = settings.input_links ? JSON.parse(settings.input_links) : [];
    } catch (e) {
      this.error('Failed to parse input_links:', e);
      return;
    }

    // 🔧 Viktig: persister på instansen for senere bruk (poll/re-fetch)
    this.inputLinks = inputLinks;

    this.log(`Setting up ${inputLinks.length} device links`);
    for (const link of inputLinks) {
      try {
        this.log(`\n=== Setting up link for input ${link.input?.toUpperCase()} ===`);
        await this.setupDeviceListener(link);
        this.log(`=== Completed setup for input ${link.input?.toUpperCase()} ===\n`);
      } catch (e) {
        this.error(`Failed to setup listener for input ${link.input}:`, e);
      }
    }

    this.log('\n=== Fetching initial values for all inputs ===');
    await this.fetchInitialValues(inputLinks);
    this.log('=== Initial values fetch complete ===\n');

    this.log('Device links setup complete');
  }


  async fetchInitialValues(inputLinks) {
    if (!this.homey.app.api) {
      this.error('App API not available for fetching initial values');
      return;
    }

    for (const link of inputLinks) {
      const { input, deviceId, capability, deviceName } = link;
      
      if (!input || !deviceId || !capability) {
        continue;
      }

      try {
        this.log(`[${input.toUpperCase()}] Fetching initial value...`);
        
        const device = await this.homey.app.api.devices.getDevice({ id: deviceId });
        
        if (!device) {
          this.log(`[${input.toUpperCase()}] ❌ Device not found`);
          continue;
        }

        let initialValue = null;

        if (device.capabilitiesObj && device.capabilitiesObj[capability]) {
          initialValue = device.capabilitiesObj[capability].value;
          this.log(`[${input.toUpperCase()}] ✔ Got value from capabilitiesObj: ${initialValue}`);
        } else if (device.capabilityValues && device.capabilityValues[capability] !== undefined) {
          initialValue = device.capabilityValues[capability];
          this.log(`[${input.toUpperCase()}] ✔ Got value from capabilityValues: ${initialValue}`);
        } else if (device.state && device.state[capability] !== undefined) {
          initialValue = device.state[capability];
          this.log(`[${input.toUpperCase()}] ✔ Got value from state: ${initialValue}`);
        }

        if (initialValue !== null && initialValue !== undefined) {
          const boolValue = this.convertToBoolean(initialValue, capability);
          this.log(`[${input.toUpperCase()}] ✔ Initial value: ${initialValue} → ${boolValue}`);
          
          for (const formula of this.formulas) {
            formula.inputStates[input] = boolValue;
            this.log(`[${input.toUpperCase()}] Set in '${formula.name}' to ${boolValue}`);
          }
        } else {
          this.log(`[${input.toUpperCase()}] ⚠️ No initial value found - waiting for first event`);
        }

      } catch (e) {
        this.error(`[${input.toUpperCase()}] Error fetching initial value:`, e.message);
      }
    }
  }

  async refetchInputsAndEvaluate(source = 'unknown') {
    this.log(`🔁 Refetch+Eval invoked (source=${source})`);
    let links = [];
    try {
      const settings = this.getSettings();
      links = settings.input_links ? JSON.parse(settings.input_links) : [];
    } catch (e) {
      this.error('Failed to parse input_links during refetch:', e.message);
    }

    if (!Array.isArray(links) || links.length === 0) {
      this.warn('⚠️ No input links available during refetch; skipping value fetch.');
      await this.evaluateAllFormulasInitial();
      return;
    }

    // Persistér for senere bruk (polling, re-evaluering, osv.)
    this.inputLinks = links;

    this.log('📥 Refetching initial values before evaluation...');
    await this.fetchInitialValues(links);
    await this.evaluateAllFormulasInitial();
  }

async setupDeviceListener(link) {
  const { input, deviceId, capability, deviceName } = link;

  this.log(`\n[${input.toUpperCase()}] ========== SETUP START ==========`); 
  this.log(`[${input.toUpperCase()}] Device Name: ${deviceName}`);
  this.log(`[${input.toUpperCase()}] Device ID: ${deviceId}`);
  this.log(`[${input.toUpperCase()}] Capability: ${capability}`);

  if (!input || !deviceId || !capability) {
    this.error(`[${input?.toUpperCase?.() ?? '?'}] Invalid link configuration:`, link);
    return;
  }

  try {
    if (!this.homey.app.api) {
      this.error(`[${input.toUpperCase()}] App API not available!`);
      return;
    }

    this.log(`[${input.toUpperCase()}] Getting all devices from API...`);
    const allDevices = await this.homey.app.api.devices.getDevices();
    this.log(
      `[${input.toUpperCase()}] Total devices found: ${Object.keys(allDevices).length}`
    );

    const targetDevice = allDevices[deviceId];
    if (!targetDevice) {
      this.error(`[${input.toUpperCase()}] ❌ Device not found: ${deviceId}`);
      const sampleIds = Object.keys(allDevices).slice(0, 5);
      this.error(`[${input.toUpperCase()}] Sample device IDs:`, sampleIds);
      return;
    }

    this.log(`[${input.toUpperCase()}] ✔ Found device: ${targetDevice.name}`);
    this.log(`[${input.toUpperCase()}] Device capabilities:`, targetDevice.capabilities);

    if (!targetDevice.capabilities || !targetDevice.capabilities.includes(capability)) {
      this.error(`[${input.toUpperCase()}] ❌ Device missing capability: ${capability}`);
      this.error(`[${input.toUpperCase()}] Available:`, targetDevice.capabilities);
      return;
    }
    this.log(`[${input.toUpperCase()}] ✔ Device has capability: ${capability}`);

    // --- Prøv å hente initialverdi (best-effort, vi gjør uansett en egen fetch senere) ---
    let initialValue = null;
    this.log(`[${input.toUpperCase()}] Attempting to get initial value...`);
    if (targetDevice.capabilityValues && targetDevice.capabilityValues[capability] !== undefined) {
      initialValue = targetDevice.capabilityValues[capability];
      this.log(`[${input.toUpperCase()}] ✔ Method 1 (capabilityValues): ${initialValue}`);
    } else if (targetDevice.capabilityInstances && targetDevice.capabilityInstances[capability]) {
      initialValue = targetDevice.capabilityInstances[capability].value;
      this.log(`[${input.toUpperCase()}] ✔ Method 2 (capabilityInstances): ${initialValue}`);
    } else if (targetDevice.state && targetDevice.state[capability] !== undefined) {
      initialValue = targetDevice.state[capability];
      this.log(`[${input.toUpperCase()}] ✔ Method 3 (state): ${initialValue}`);
    } else {
      try {
        this.log(`[${input.toUpperCase()}] Trying to fetch current value...`);
        const deviceState = await this.homey.app.api.devices.getDevice({ id: deviceId });
        if (deviceState && deviceState.capabilityValues) {
          initialValue = deviceState.capabilityValues[capability];
          this.log(`[${input.toUpperCase()}] ✔ Method 4 (fresh fetch): ${initialValue}`);
        }
      } catch (e) {
        this.log(`[${input.toUpperCase()}] Method 4 failed:`, e.message);
      }
    }

    if (initialValue !== null && initialValue !== undefined) {
      const boolValue = this.convertToBoolean(initialValue, capability);
      this.log(
        `[${input.toUpperCase()}] ✔ Initial value: ${initialValue} → ${boolValue}`
      );
      for (const formula of this.formulas) {
        formula.inputStates[input] = boolValue;
        this.log(
          `[${input.toUpperCase()}] Set in '${formula.name}' to ${boolValue}`
        );
      }
    } else {
      this.log(
        `[${input.toUpperCase()}] ⚠️ No initial value - waiting for first event`
      );
    }

    // --- Event-listener ---
    const listenerFn = async (value) => {
      // Kortslutt hvis devicen er i sletting
      if (this._isDeleting) return;

      this.log(`\n*** [${input.toUpperCase()}] EVENT RECEIVED ***`);
      this.log(`Device: ${targetDevice.name}`);
      this.log(`Capability: ${capability}`);
      this.log(`Raw value: ${value}`);

      const boolValue = this.convertToBoolean(value, capability);
      this.log(`Boolean value: ${boolValue}`);

      for (const formula of this.formulas) {
        this.log(
          `Updating '${formula.name}' input ${input.toUpperCase()} → ${boolValue}`
        );
        try {
          await this.setInputForFormula(formula.id, input, boolValue);
        } catch (err) {
          if (!this._isDeleting) this.error('setInputForFormula error:', err);
        }
      }
      this.log(`*** [${input.toUpperCase()}] EVENT COMPLETE ***\n`);
    };

    // Registrering + oppsett av "unregister"
    this.log(`[${input.toUpperCase()}] Registering capability listener...`);
    let registered = false;
    let unregister = null;
    let eventName = `capability.${capability}`;

    // makeCapabilityInstance (SDK)
    if (typeof targetDevice.makeCapabilityInstance === 'function') {
      try {
        this.log(`[${input.toUpperCase()}] Trying makeCapabilityInstance...`);
        const instance = targetDevice.makeCapabilityInstance(capability, listenerFn);
        // I Homey SDK er det vanlig at instance har .destroy()
        unregister = async () => {
          try {
            if (instance && typeof instance.destroy === 'function') {
              instance.destroy();
            }
          } catch (e) {
            this.error(`[${input.toUpperCase()}] Error destroying capability instance:`, e.message);
          }
        };
        this.log(`[${input.toUpperCase()}] ✔ Registered via makeCapabilityInstance`);
        registered = true;
      } catch (e) {
        this.error(`[${input.toUpperCase()}] makeCapabilityInstance failed:`, e.message);
      }
    }

    // device.on fallback (EventEmitter-lignende)
    if (!registered && typeof targetDevice.on === 'function') {
      try {
        this.log(`[${input.toUpperCase()}] Trying device.on('${eventName}')...`);
        targetDevice.on(eventName, listenerFn);
        unregister = async () => {
          try {
            if (typeof targetDevice.removeListener === 'function') {
              targetDevice.removeListener(eventName, listenerFn);
            }
          } catch (e) {
            this.error(`[${input.toUpperCase()}] Error removing listener:`, e.message);
          }
        };
        this.log(`[${input.toUpperCase()}] ✔ Registered via device.on`);
        registered = true;
      } catch (e) {
        this.error(`[${input.toUpperCase()}] device.on failed:`, e.message);
      }
    }

    if (!registered) {
      this.error(
        `[${input.toUpperCase()}] ❌ Could not register listener!`
      );
      this.log(
        `[${input.toUpperCase()}] Available methods:`,
        Object.keys(targetDevice).filter(k => typeof targetDevice[k] === 'function').slice(0, 10)
      );
    }

    const listenerKey = `${input}-${deviceId}-${capability}`;
    this.deviceListeners.set(listenerKey, {
      deviceId,
      capability,
      input,
      device: targetDevice,
      listener: listenerFn,
      registered,
      unregister, // 👈 LAGRER UNREGISTER
      eventName
    });

    this.log(`[${input.toUpperCase()}] ========== SETUP COMPLETE ==========\n`);
  } catch (e) {
    this.error(`[${input.toUpperCase()}] ❌ SETUP FAILED:`, e.message);
    this.error(`[${input.toUpperCase()}] Stack:`, e.stack);
  }
}

  convertToBoolean(value, capability) {
    if (typeof value === 'boolean') {
      return value;
    }
    
    if (capability.startsWith('alarm_')) {
      return !!value;
    }
    
    if (capability === 'onoff') {
      return !!value;
    }
    
    if (typeof value === 'number') {
      return value > 0;
    }
    
    if (typeof value === 'string') {
      const lowerValue = value.toLowerCase();
      return lowerValue === 'true' || lowerValue === '1' || lowerValue === 'on' || lowerValue === 'yes';
    }
    
    return !!value;
  }

  async safeSetCapabilityValue(cap, value) {
    // Ikke gjør noe hvis enheten er i ferd med å slettes
    if (this._isDeleting) return;
    try {
      // Valgfritt: hopp over hvis capability ikke finnes
      if (!this.hasCapability(cap)) return;

      await this.setCapabilityValue(cap, value);
    } catch (e) {
      // Ignorer 404 / Not Found – typisk etter sletting
      const msg = e?.message || '';
      if (e?.statusCode === 404 || /not\s*found/i.test(msg)) {
        this.log(`(safe) Skipper ${cap} – enheten finnes ikke lenger.`);
        return;
      }
      // Andre feil logges – men knekker ikke flyten
      this.error(`Capability update failed for ${cap}:`, msg);
    }
  }

  async setInputForFormula(formulaId, inputId, value) {
    if (this._isDeleting) return null;
    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula) {
      return null;
    }
    
    if (formula.firstImpression && formula.lockedInputs[inputId]) {
      this.log(`⚠️ Input '${inputId.toUpperCase()}' locked for formula '${formula.name}' (firstImpression mode)`);
      return formula.result;
    }
    
    const oldValue = formula.inputStates[inputId];
    this.log(`Setting input '${inputId.toUpperCase()}' to ${value} for formula '${formula.name}' (was: ${oldValue})`);
    
    formula.inputStates[inputId] = value;
    formula.timedOut = false;
    
    if (formula.firstImpression && value !== 'undefined' && !formula.lockedInputs[inputId]) {
      formula.lockedInputs[inputId] = true;
      this.log(`🔒 Input '${inputId.toUpperCase()}' locked at value ${value} (firstImpression mode)`);
    }
    
    if (value !== 'undefined') {
      formula.lastInputTime = Date.now();
    }
    
    return await this.evaluateFormula(formulaId);
  }

  async evaluateFormula(formulaId, resetLocks = false) {
    if (this._isDeleting) return null;
    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula || !formula.enabled) {
      this.log(`Formula '${formulaId}' not found or disabled.`);
      return null;
    }

    if (resetLocks && formula.firstImpression) {
      this.availableInputs.forEach(id => {
        formula.lockedInputs[id] = false;
      });
      this.log(`🔓 Unlocked all inputs for formula '${formula.name}'`);
    }

    const expression = formula.expression;
    if (!expression) {
      this.log('No expression set, cannot evaluate.');
      return null;
    }

    const requiredInputs = this.parseExpression(expression);
    if (requiredInputs.length === 0) return null;

    const allInputsDefined = requiredInputs.every(id => 
      formula.inputStates[id.toLowerCase()] !== 'undefined'
    );
    
    if (!allInputsDefined) {
      this.log(`Formula '${formula.name}': Waiting for inputs. Required: [${requiredInputs.join(', ')}]`);
      return null;
    }

    const values = {};
    this.availableInputs.forEach(id => {
      values[id.toUpperCase()] = formula.inputStates[id];
    });

    this.log(`Formula '${formula.name}': Evaluating with inputs:`, values);

    let evalExpression = expression
      .replace(/\bAND\b|&|\*/gi, '&&')
      .replace(/\bOR\b|\||\+/gi, '||')
      .replace(/\bXOR\b|\^|!=/gi, '!=')
      .replace(/\bNOT\b/gi, '!');

    for (const key in values) {
      if (values[key] !== 'undefined') {
        const regex = new RegExp(`\\b${key}\\b`, 'gi');
        evalExpression = evalExpression.replace(regex, values[key]);
      }
    }

    this.log(`Evaluating: "${expression}" → "${evalExpression}"`);

    try {
      const evaluate = new Function(`return ${evalExpression}`);
      const result = !!evaluate();

      this.log(`✅ Formula '${formula.name}' result: ${result}`);
      
      const previousResult = formula.result;
      formula.result = result;
      formula.timedOut = false;
      
      try {
        await this.safeSetCapabilityValue('onoff', result);
        await this.safeSetCapabilityValue('alarm_generic', result);
      } catch (e) {
        if (e.statusCode === 404) {
          this.log('Device deleted, skipping capability update');
          return null;
        }
        throw e;
      }
      
      if (previousResult !== null && previousResult !== result) {
        const triggerData = {
          formula: {
            id: formulaId,
            name: formula.name
          }
        };
        
        const state = { formulaId };
        
        try {
          if (result) {
            await this.homey.flow.getDeviceTriggerCard('formula_changed_to_true')
              .trigger(this, triggerData, state);
          } else {
            await this.homey.flow.getDeviceTriggerCard('formula_changed_to_false')
              .trigger(this, triggerData, state);
          }
          
          await this.homey.flow.getDeviceTriggerCard('device_state_changed')
            .trigger(this, { state: result }, {});
            
        } catch (e) {
          if (e.statusCode === 404) {
            this.log('Device deleted, skipping flow trigger');
            return null;
          }
          this.error('Error triggering flow:', e);
        }
      }

      return result;

    } catch (e) {
      this.error(`❌ Failed to evaluate formula '${formula.name}': ${e.message}`);
      return null;
    }
  }

  async evaluateAllFormulasInitial() {
    this.log('Initial evaluation of all formulas...');
    
    let anyEvaluated = false;
    
    for (const formula of this.formulas) {
      if (!formula.enabled) continue;
      
      const expression = formula.expression;
      if (!expression) continue;
      
      const requiredInputs = this.parseExpression(expression);
      if (requiredInputs.length === 0) continue;
      
      const allInputsDefined = requiredInputs.every(id => 
        formula.inputStates[id.toLowerCase()] !== 'undefined'
      );
      
      if (allInputsDefined) {
        this.log(`Formula '${formula.name}': All inputs defined, evaluating...`);
        await this.evaluateFormula(formula.id);
        anyEvaluated = true;
      } else {
        const states = {};
        requiredInputs.forEach(id => {
          states[id] = formula.inputStates[id.toLowerCase()];
        });
        this.log(`Formula '${formula.name}': Missing inputs:`, states);
      }
    }
    
    if (!anyEvaluated) {
      this.log('⚠️ No formulas could be evaluated - waiting for input values');
      await this.safeSetCapabilityValue('onoff', false);
      await this.safeSetCapabilityValue('alarm_generic', false);
    }
  }

  parseExpression(expression) {
    const inputs = this.getAvailableInputsUppercase(); // f.eks. ['A','B','C']
    if (!inputs.length) return [];
    const varRe = new RegExp(`\\b(${inputs.join('|')})\\b`, 'gi');
    const matches = expression.match(varRe);
    return matches ? [...new Set(matches.map(c => c.toUpperCase()))] : [];
  }

  validateExpression(expression) {
    if (!expression || expression.trim() === '') {
      return { valid: false, error: 'Expression cannot be empty' };
    }

    const upper = expression.toUpperCase();
    const inputs = this.getAvailableInputsUppercase();
    if (!inputs.length) return { valid: false, error: 'No inputs available' };

    // Tokeniser: ord-operatorer, symbol-operatorer, paranteser og inputs
    const tokenRe = new RegExp(
      `\\b(?:AND|OR|XOR|NOT)\\b|&&|\\|\\||\\^|!=|\\*|\\+|!|\\(|\\)|\\b(?:${inputs.join('|')})\\b`,
      'gi'
    );

    // Finn ugyldige rester
    const stripped = upper.replace(tokenRe, '').replace(/\s+/g, '');
    if (stripped.length > 0) {
      return { valid: false, error: `Invalid tokens in expression: "${stripped}"` };
    }

    // Grov parantes-sjekk
    let depth = 0;
    for (const ch of upper) {
      if (ch === '(') depth++;
      else if (ch === ')') depth--;
      if (depth < 0) return { valid: false, error: 'Unbalanced parentheses' };
    }
    if (depth !== 0) return { valid: false, error: 'Unbalanced parentheses' };

    // Syntaks-test: normaliser til JS og evaluer med dummyverdier
    let testExpr = upper
      .replace(/\bAND\b|&&|\*/g, '&&')
      .replace(/\bOR\b|\|\||\+/g, '||')
      .replace(/\bXOR\b|\^|!=/g, '!=')  // boolsk XOR ~= ulikhet
      .replace(/\bNOT\b|!/g, '!');

    for (const key of inputs) {
      const re = new RegExp(`\\b${key}\\b`, 'g');
      testExpr = testExpr.replace(re, 'true');
    }

    try {
      // eslint-disable-next-line no-new-func
      const fn = new Function(`return ${testExpr}`);
      void fn();
      return { valid: true };
    } catch (e) {
      return { valid: false, error: `Invalid expression syntax: ${e.message}` };
    }
  }

  getFormulas() {
    return this.formulas
      .filter(f => f.enabled)
      .map(f => ({
        id: f.id,
        name: f.name,
        description: f.expression || '(no expression)'
      }));
  }

  getInputOptions() {
    return this.getAvailableInputsUppercase().map(input => ({
      id: input.toLowerCase(),
      name: input
    }));
  }

  getFormulaResult(formulaId) {
    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula) {
      this.log(`getFormulaResult: Formula '${formulaId}' not found`);
      return null;
    }
    
    return formula.result;
  }

  hasFormulaTimedOut(formulaId) {
    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula) return false;
    return formula.timedOut;
  }

  async evaluateAllFormulas() {
    this.log('Re-evaluating all formulas (resetting locks)...');
    
    const results = [];
    for (const formula of this.formulas) {
      if (formula.enabled) {
        this.availableInputs.forEach(id => {
          formula.lockedInputs[id] = false;
        });
        this.log(`🔓 Unlocked all inputs for formula '${formula.name}'`);
        
        const result = await this.evaluateFormula(formula.id);
        results.push({ id: formula.id, name: formula.name, result });
      }
    }
    
    this.log(`Evaluated ${results.length} formulas`);
    return results;
  }

  startTimeoutChecks() {
    this.timeoutInterval = setInterval(() => {
      this.checkTimeouts();
    }, 1000);
  }

  checkTimeouts() {
    const now = Date.now();
    
    this.formulas.forEach(formula => {
      if (!formula.timeout || formula.timeout <= 0) return;
      if (formula.timedOut || !formula.enabled) return;
      if (!formula.lastInputTime) return;
      
      const hasAnyInput = this.availableInputs.some(id => 
        formula.inputStates[id] !== 'undefined'
      );
      
      if (!hasAnyInput) return;
      
      const requiredInputs = this.parseExpression(formula.expression);
      const allInputsDefined = requiredInputs.every(id => 
        formula.inputStates[id.toLowerCase()] !== 'undefined'
      );
      
      if (allInputsDefined) return;
      
      const timeoutMs = formula.timeout * 1000;
      const elapsed = now - formula.lastInputTime;
      
      if (elapsed >= timeoutMs) {
        this.log(`⏱️ Formula '${formula.name}' timed out after ${formula.timeout}s`);
        formula.timedOut = true;
        
        const triggerData = {
          formula: {
            id: formula.id,
            name: formula.name
          }
        };
        
        const state = {
          formulaId: formula.id
        };
        
        this.homey.flow.getDeviceTriggerCard('formula_timeout')
          .trigger(this, triggerData, state)
          .catch(err => this.error('Error triggering timeout:', err));
      }
    });
  }

  async onSettings({ oldSettings, newSettings, changedKeys }) {
    this.log('Settings changed:', changedKeys);

    if (this.timeoutInterval) {
      clearInterval(this.timeoutInterval);
    }

    // 1) Oppdater kapasitet hvis formler eller koblinger antyder flere inputs
    if (changedKeys.includes('formulas') || changedKeys.includes('input_links')) {
      const detectedInputs = this.detectRequiredInputs(newSettings);
      const originalNumInputs = this.getData().numInputs ?? 2;
      const newNumInputs = Math.max(detectedInputs, originalNumInputs);
      if (newNumInputs !== this.numInputs) {
        this.log(`📊 Updating capacity: ${this.numInputs} → ${newNumInputs} inputs`);
        this.numInputs = newNumInputs;
        this.availableInputs = this.getAvailableInputIds();
      }
    }

    // 2) Autoformat-buffer
    const formatSettings = {};
    let needsFormat = false;

    // 3) Parse/autoformat formler
    let parsedFormulas = [];
    if (changedKeys.includes('formulas')) {
      try {
        let rawFormulas = newSettings.formulas;
        this.log('[onSettings] Raw formulas input:', rawFormulas);
        parsedFormulas = typeof rawFormulas === 'string' ? JSON.parse(rawFormulas) : rawFormulas;
        this.log('[onSettings] Parsed formulas:', parsedFormulas);

        const formatted = JSON.stringify(parsedFormulas, null, 2);
        const original = typeof newSettings.formulas === 'string' ? newSettings.formulas : JSON.stringify(newSettings.formulas);
        if (formatted !== original) {
          formatSettings.formulas = formatted;
          needsFormat = true;
          this.log('Will auto-format formulas JSON');
        }
      } catch (e) {
        this.error('Could not parse formulas:', e.message);
        throw new Error(`Invalid formulas JSON: ${e.message}`);
      }
    }

    // 4) Parse/autoformat input_links (kun hvis de faktisk endret seg)
    let parsedLinks = [];
    if (changedKeys.includes('input_links')) {
      try {
        let rawLinks = newSettings.input_links;
        this.log('[onSettings] Raw input_links:', rawLinks);
        parsedLinks = typeof rawLinks === 'string' ? JSON.parse(rawLinks) : rawLinks;

        const formatted = JSON.stringify(parsedLinks, null, 2);
        const original = typeof newSettings.input_links === 'string' ? newSettings.input_links : JSON.stringify(newSettings.input_links);
        if (formatted !== original) {
          formatSettings.input_links = formatted;
          needsFormat = true;
          this.log('Will auto-format input_links JSON');
        }
      } catch (e) {
        this.error('Could not parse input_links:', e.message);
        throw new Error(`Invalid input_links JSON: ${e.message}`);
      }
    }

    // 5) Re-initialiser formelstrukturen ved formelendring
    if (changedKeys.includes('formulas')) {
      this.formulas = parsedFormulas.map(f => ({
        id: f.id,
        name: f.name,
        expression: f.expression,
        enabled: f.enabled !== false,
        timeout: f.timeout ?? 0,
        firstImpression: f.firstImpression === true,
        inputStates: {},
        lockedInputs: {},
        lastInputTime: null,
        result: null,
        timedOut: false,
      }));

      this.availableInputs.forEach(id => {
        this.formulas.forEach(f => {
          f.inputStates[id] = 'undefined';
          f.lockedInputs[id] = false;
        });
      });

      this.log(`Initialized ${this.formulas.length} formulas`);
      this.formulas.forEach(f => {
        this.log(` - ${f.name}: "${f.expression}" (enabled: ${f.enabled})`);
      });

      // Valider uttrykkene
      for (const formula of this.formulas) {
        const validation = this.validateExpression(formula.expression);
        this.log(`[onSettings] Validation for "${formula.expression}":`, validation);
        if (!validation.valid) {
          throw new Error(`Formula '${formula.name}': ${validation.error}`);
        }
      }
    }

    // 6) Hvis koblinger endret seg: sett opp lyttere og (re)hent initialverdier
    if (changedKeys.includes('input_links')) {
      await this.setupDeviceLinks();         // setter this.inputLinks + fetchInitialValues(...)
      await this.evaluateAllFormulasInitial();
    }

    // 7) Hvis KUN formler endret seg: hent verdier før evaluering
    if (changedKeys.includes('formulas') && !changedKeys.includes('input_links')) {
      await this.refetchInputsAndEvaluate('formulas-change');
    }

    this.startTimeoutChecks();
    this.log('Settings applied successfully');

    // 8) Autoformat settings etterpå
    if (needsFormat) {
      setTimeout(async () => {
        try {
          this.log('Applying formatted settings...');
          await this.setSettings(formatSettings);
          this.log('✨ Settings auto-formatted');
        } catch (e) {
          this.error('Failed to auto-format settings:', e.message);
        }
      }, 500);
    }
  }

  async pollDeviceInputs() {
    this.log('🔄 Polling all linked device inputs...');

    const links = this.inputLinks || [];
    if (!links.length) {
      this.warn('⚠️ No inputLinks available for polling');
      return;
    }
    if (!this.homey.app.api) {
      this.error('App API not available for polling');
      return;
    }

    for (const link of links) {
      this.log(`🔗 Polling input "${link.input}" from device "${link.deviceId}" using capability "${link.capability}"`);
      try {
        const dev = await this.homey.app.api.devices.getDevice({ id: link.deviceId });
        if (!dev) {
          this.warn(`⚠️ Device not found: ${link.deviceId}`);
          continue;
        }

        let raw = null;
        if (dev.capabilitiesObj && dev.capabilitiesObj[link.capability]) {
          raw = dev.capabilitiesObj[link.capability].value;
        } else if (dev.capabilityValues && dev.capabilityValues[link.capability] !== undefined) {
          raw = dev.capabilityValues[link.capability];
        } else if (dev.state && dev.state[link.capability] !== undefined) {
          raw = dev.state[link.capability];
        }

        if (raw === null || raw === undefined) {
          this.log(`⚠️ No value for ${link.input.toUpperCase()} (${link.capability})`);
          continue;
        }

        const boolValue = this.convertToBoolean(raw, link.capability);
        this.log(`📥 Polled ${link.input.toUpperCase()}: ${raw} → ${boolValue}`);

        for (const formula of this.formulas) {
          formula.inputStates[link.input] = boolValue;
          if (boolValue !== 'undefined') {
            formula.lastInputTime = Date.now();
          }
        }
      } catch (e) {
        this.error(`❌ Failed to poll ${link.input}:`, e.message);
      }
    }
  }

async onDeleted() {
  this._isDeleting = true; // 👈 signaliser til eventer at vi er på vei ut
  this.log('Device deleted — cleaning up listeners & timers');

  // Prøv å unregister’e alle listeners vi har lagret
  for (const [key, entry] of this.deviceListeners.entries()) {
    try {
      if (typeof entry?.unregister === 'function') {
        await entry.unregister();
        this.log(`Unregistered listener: ${key}`);
      } else if (entry?.device && entry?.listener && typeof entry.device.removeListener === 'function') {
        // Best effort fallback for device.on(...) varianter
        const ev = entry.eventName || (entry.capability ? `capability.${entry.capability}` : undefined);
        if (ev) entry.device.removeListener(ev, entry.listener);
        this.log(`Removed listener via removeListener: ${key}`);
      }
    } catch (e) {
      this.error('Error cleaning up listener:', e);
    }
  }
  this.deviceListeners.clear();

  // Stopp eventuelle intervaller (timeouts tikker i egen metode hos deg)
  if (this.timeoutInterval) {
    clearInterval(this.timeoutInterval);
    this.timeoutInterval = null;
  }

  // Frigi evt. andre ressurser (om du senere bruker pollingIntervals etc.)
  if (this.pollingIntervals && typeof this.pollingIntervals.clear === 'function') {
    try { this.pollingIntervals.clear(); } catch (_) {}
  }

  this.log('Cleanup complete');
}
};
--- END: drivers/logic-device/device.js ---

--- START: drivers/logic-device/driver.js (sha256=9b1f1ea627a65da484a328b91767acad8ad0006a5d9a14f4186d7f4563929ddc, bytes=4281) ---
'use strict';

const Homey = require('homey');

module.exports = class LogicDeviceDriver extends Homey.Driver {
  async ensureUniqueDeviceName(name) {
    try {
      // Bruk Athom API som appen allerede initialiserer (app.js)
      if (!this.homey.app.api) return name;
      const all = await this.homey.app.api.devices.getDevices();
      const existingNames = new Set(
        Object.values(all).map(d => (d?.name || '').trim()).filter(Boolean)
      );

      if (!existingNames.has(name)) return name;

      // Fjern ev. trailing tall for å finne base
      const base = name.replace(/\s+\d+$/, '').trim();
      // Hvis det allerede er et tall bakerst, start fra n+1, ellers 2
      const m = name.match(/\s+(\d+)$/);
      let n = m ? (parseInt(m[1], 10) + 1) : 2;

      let candidate = `${base} ${n}`;
      while (existingNames.has(candidate)) {
        n++;
        candidate = `${base} ${n}`;
      }
      return candidate;
    } catch (e) {
      this.error('ensureUniqueDeviceName failed:', e.message);
      // Fall back til opprinnelig navn ved feil
      return name;
    }
  }

  async onInit() {
    this.log('Logic Device Driver has been initialized');
  }

  async onPair(session) {
    this.log('=== PAIRING SESSION STARTED ===');
    
    let numInputs = 2;
    let inputLinks = [];
    let deviceName = 'Logic Device';

    session.setHandler('get_num_inputs', async () => {
      this.log('[HANDLER] get_num_inputs called');
      return { numInputs };
    });

    session.setHandler('set_num_inputs', async (data) => {
      this.log('[HANDLER] set_num_inputs called with data:', data);
      numInputs = parseInt(data.numInputs);
      return { success: true };
    });

    session.setHandler('get_zones', async () => {
      this.log('[HANDLER] get_zones called');
      try {
        return await this.homey.app.getAvailableZones();
      } catch (e) {
        this.error('[HANDLER] ERROR in get_zones:', e.message);
        throw new Error(`Failed to get zones: ${e.message}`);
      }
    });

    session.setHandler('get_devices_in_zone', async (data) => {
      this.log(`[HANDLER] get_devices_in_zone called for zone: ${data.zoneId}`);
      if (!data.zoneId) return [];
      try {
        return await this.homey.app.getDevicesInZone(data.zoneId);
      } catch (e) {
        this.error('[HANDLER] ERROR in get_devices_in_zone:', e.message);
        throw new Error(`Failed to get devices: ${e.message}`);
      }
    });

    session.setHandler('set_input_links', async (data) => {
      this.log('[HANDLER] set_input_links called');
      inputLinks = data.inputLinks;
      return { success: true };
    });

    session.setHandler('set_device_name', async (data) => {
      this.log('[HANDLER] set_device_name called with:', data.name);
      deviceName = data.name;
      return { success: true };
    });

    // Opprett device når bruker klikker Complete

    session.setHandler('create_device', async () => {
      this.log('[HANDLER] create_device called');

      if (!inputLinks || inputLinks.length === 0) {
        throw new Error('No input links configured!');
      }

      // 🔧 Sjekk om navnet finnes – legg på tall/øk ved behov
      const uniqueName = await this.ensureUniqueDeviceName(deviceName);

      const device = {
        name: uniqueName,
        data: {
          id: `logic-device-${Date.now()}`,
          numInputs
        },
        settings: {
          input_links: JSON.stringify(inputLinks),
          formulas: JSON.stringify([{
            id: 'formula_1',
            name: 'Main Formula',
            expression: this.getDefaultExpression(numInputs),
            enabled: true,
            timeout: 0,
            firstImpression: false // Default FALSE for kontinuerlig evaluering
          }])
        }
      };
      
      this.log('[HANDLER] Creating device:', JSON.stringify(device, null, 2));
      return device;
    });

    this.log('=== PAIRING HANDLERS REGISTERED ===');
  }

  getDefaultExpression(numInputs) {
    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    return letters.slice(0, numInputs).join(' AND ');
  }
};
--- END: drivers/logic-device/driver.js ---

--- START: drivers/logic-device/pair/configure_inputs.html (sha256=fcfe4bc63ad64f4302cfe293b3082b4a31481fbc20c0e0f782d92b89590af1d3, bytes=15901) ---
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      transition: opacity 0.3s ease-in-out;
    }
    .fade-out {
      opacity: 0;
      pointer-events: none;
    }
    .fade-in {
      opacity: 1;
    }
    h2 {
      margin-bottom: 10px;
      color: #333;
    }
    .description {
      color: #666;
      margin-bottom: 30px;
      line-height: 1.5;
    }
    .input-config {
      margin-bottom: 25px;
      padding: 20px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background-color: #fafafa;
      transition: all 0.3s ease;
    }
    .input-config.complete {
      border-color: #4CAF50;
      background-color: #f1f8f4;
    }
    .input-config h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 18px;
    }
    .input-config label {
      display: block;
      margin-top: 12px;
      margin-bottom: 5px;
      font-weight: 500;
      color: #555;
      font-size: 14px;
    }
    select {
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: white;
      transition: border-color 0.2s;
    }
    select:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
    }
    select:disabled {
      background-color: #f5f5f5;
      cursor: not-allowed;
    }
    .status {
      margin-top: 10px;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    .status.complete {
      background-color: #4CAF50;
      color: white;
    }
    .status.incomplete {
      background-color: #ff9800;
      color: white;
    }
    .summary {
      margin-top: 30px;
      padding: 20px;
      background-color: #e3f2fd;
      border-radius: 8px;
      border-left: 4px solid #2196F3;
    }
    .summary strong {
      color: #1976D2;
    }
    .device-name-section {
      margin-top: 30px;
      padding: 20px;
      background-color: #fff3e0;
      border-radius: 8px;
      border-left: 4px solid #ff9800;
    }
    .device-name-section label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #555;
    }
    .device-name-section input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 5px;
      box-sizing: border-box;
    }
    .device-name-section input:focus {
      outline: none;
      border-color: #ff9800;
      box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
      font-size: 16px;
      transition: opacity 0.3s ease;
    }
    .loading:before {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #4CAF50;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }
    button {
      padding: 15px 40px;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      width: 100%;
      margin-top: 20px;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    button.btn-enabled {
      background-color: #4CAF50 !important;
      cursor: pointer !important;
      pointer-events: auto !important;
    }

    button.btn-disabled {
      background-color: #cccccc !important;
      cursor: not-allowed !important;
      pointer-events: none !important;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .error {
      background-color: #ffebee;
      color: #c62828;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      border-left: 4px solid #c62828;
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Configure inputs</h2>
    <p class="description">Select which device and capability each input should follow:</p>
    
    <div id="loading" class="loading">
      Loading devices...
    </div>
    
    <div id="inputs-container" style="display: none;"></div>

    <div id="device-name-section" class="device-name-section" style="display: none;">
      <label for="deviceName">Give the device a name:</label>
      <input type="text" id="deviceName" placeholder="E.g: Bedroom logic" value="Logic Device">
    </div>

    <div id="summary" class="summary" style="display: none;"></div>

    <div id="error-message" class="error" style="display: none;"></div>
    
    <button id="complete-btn">...</button>
  </div>

<script>
    document.getElementById('complete-btn').addEventListener('click', visVarsel);

    async function visVarsel() {
      try {
        const inputLinks = [];
        const deviceName = document.getElementById('deviceName').value || 'Logic Device';
        
        for (let i = 0; i < numInputs; i++) {
          const inputId = letters[i].toLowerCase();
          const deviceSelect = document.getElementById(`device-${inputId}`);
          const deviceId = deviceSelect?.value;
          const capability = document.getElementById(`capability-${inputId}`)?.value;
          
          if (deviceId && capability) {
            // Hent også device name fra selected option
            const selectedOption = deviceSelect.options[deviceSelect.selectedIndex];
            const deviceName = selectedOption?.text || 'Unknown Device';
            
            inputLinks.push({ 
              input: inputId, 
              deviceId, 
              capability,
              deviceName  // Lagre device name
            });
          }
        }
        
        if (inputLinks.length !== numInputs) {
          await Homey.alert('Please configure all inputs first!', 'warning');
          return;
        }
        
        await Homey.emit('set_input_links', { inputLinks });
        await Homey.emit('set_device_name', { name: deviceName });
        
        const deviceData = await Homey.emit('create_device');
        await Homey.createDevice(deviceData);
        
        await Homey.done();
        
      } catch (e) {
        console.error('Error:', e);
        await Homey.alert('Error: ' + e.message, 'error');
      }
    }

    let zones = [];
    let numInputs = 2;
    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];

    function log(message, data) {
      const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
      const logMessage = `[${timestamp}] ${message}`;
      console.log(logMessage, data || '');
    }

    function showError(message) {
      const errorEl = document.getElementById('error-message');
      errorEl.textContent = message;
      errorEl.style.display = 'block';
    }

    async function init() {
      try {
        const numInputsResult = await Homey.emit('get_num_inputs');
        numInputs = numInputsResult.numInputs || 2;
        
        log('Fetching zones...');
        zones = await Homey.emit('get_zones');
        if (!zones || zones.length === 0) {
          showError('No zones found. Please create zones in your Homey first.');
          document.getElementById('loading').style.display = 'none';
          return;
        }
        log('Zones fetched successfully', zones.length);

        document.getElementById('loading').style.display = 'none';
        document.getElementById('inputs-container').style.display = 'block';
        document.getElementById('device-name-section').style.display = 'block';
        document.getElementById('summary').style.display = 'block';
        
        renderInputs();
        
        setTimeout(() => {
          updateSummary();
        }, 100);
      } catch (e) {
        console.error('Init error:', e);
        showError('Error loading initial data: ' + e.message);
        document.getElementById('loading').style.display = 'none';
      }
    }

    function renderInputs() {
      const container = document.getElementById('inputs-container');
      container.innerHTML = '';
      
      let zoneOptions = '<option value="">-- Select zone/room --</option>';
      zones.forEach(zone => {
        zoneOptions += `<option value="${zone.id}">${zone.name}</option>`;
      });

      for (let i = 0; i < numInputs; i++) {
        const letter = letters[i];
        const inputId = letter.toLowerCase();

        const div = document.createElement('div');
        div.className = 'input-config';
        div.id = `input-config-${inputId}`;
        
        div.innerHTML = `
          <h3>Input ${letter}</h3>
          <label>Zone/Room:</label>
          <select id="zone-${inputId}" data-input="${inputId}">${zoneOptions}</select>
          <label>Device:</label>
          <select id="device-${inputId}" data-input="${inputId}" disabled><option value="">-- Select zone first --</option></select>
          <label>Capability:</label>
          <select id="capability-${inputId}" data-input="${inputId}" disabled><option value="">-- Select device first --</option></select>
          <div class="status incomplete" id="status-${inputId}">⚠️ Not configured</div>
        `;
        container.appendChild(div);

        document.getElementById(`zone-${inputId}`).addEventListener('change', (e) => onZoneChange(inputId, e.target.value));
        document.getElementById(`device-${inputId}`).addEventListener('change', (e) => onDeviceChange(inputId, e.target.value));
        document.getElementById(`capability-${inputId}`).addEventListener('change', updateSummary);
      }
    }

    async function onZoneChange(inputId, zoneId) {
      log(`Zone changed for input ${inputId}`, zoneId);
      const deviceSelect = document.getElementById(`device-${inputId}`);
      const capabilitySelect = document.getElementById(`capability-${inputId}`);
      
      deviceSelect.innerHTML = '<option value="">Loading devices...</option>';
      deviceSelect.disabled = true;
      capabilitySelect.innerHTML = '<option value="">-- Select device first --</option>';
      capabilitySelect.disabled = true;
      
      if (!zoneId) {
        deviceSelect.innerHTML = '<option value="">-- Select zone first --</option>';
        updateSummary();
        return;
      }

      try {
        const devicesInZone = await Homey.emit('get_devices_in_zone', { zoneId });
        log(`Found ${devicesInZone.length} devices in zone ${zoneId}`);
        
        deviceSelect.innerHTML = '<option value="">-- Select device --</option>';
        devicesInZone.forEach(d => {
          const option = document.createElement('option');
          option.value = d.id;
          option.dataset.capabilities = JSON.stringify(d.capabilities);
          option.textContent = `${d.name} (${d.driverName})`;
          deviceSelect.appendChild(option);
        });
        deviceSelect.disabled = false;
      } catch (e) {
        showError(`Failed to load devices for zone: ${e.message}`);
        deviceSelect.innerHTML = '<option value="">-- Error loading --</option>';
      }
      
      updateSummary();
    }

    function onDeviceChange(inputId, deviceId) {
      log(`Device changed for input ${inputId}`, deviceId);
      const deviceSelect = document.getElementById(`device-${inputId}`);
      const capabilitySelect = document.getElementById(`capability-${inputId}`);
      
      capabilitySelect.innerHTML = '<option value="">-- Select capability --</option>';
      capabilitySelect.disabled = true;
      
      if (deviceId) {
        const selectedOption = deviceSelect.querySelector(`option[value="${deviceId}"]`);
        if (selectedOption && selectedOption.dataset.capabilities) {
          const capabilities = JSON.parse(selectedOption.dataset.capabilities);
          
          capabilities.forEach(cap => {
            const option = document.createElement('option');
            option.value = cap.id;
            option.textContent = `${cap.name} (${cap.id})`;
            capabilitySelect.appendChild(option);
          });
          capabilitySelect.disabled = false;
        }
      }
      
      updateSummary();
    }

    async function saveConfigToBackend() {
      const inputLinks = [];
      const deviceName = document.getElementById('deviceName').value || 'Logic Device';
      
      for (let i = 0; i < numInputs; i++) {
        const inputId = letters[i].toLowerCase();
        const deviceSelect = document.getElementById(`device-${inputId}`);
        const deviceId = deviceSelect?.value;
        const capability = document.getElementById(`capability-${inputId}`)?.value;
        
        if (deviceId && capability) {
          // Hent device name
          const selectedOption = deviceSelect.options[deviceSelect.selectedIndex];
          const deviceName = selectedOption?.text || 'Unknown Device';
          
          inputLinks.push({ 
            input: inputId, 
            deviceId, 
            capability,
            deviceName  // Inkluder device name
          });
        }
      }
      
      if (inputLinks.length === numInputs) {
        try {
          await Homey.emit('set_input_links', { inputLinks });
          await Homey.emit('set_device_name', { name: deviceName });
        } catch (e) {
          console.error('Error saving config:', e);
        }
      }
    }    

    function updateSummary() {
      let allConfigured = true;
      let configuredCount = 0;

      for (let i = 0; i < numInputs; i++) {
        const inputId = letters[i].toLowerCase();
        const deviceId = document.getElementById(`device-${inputId}`)?.value;
        const capability = document.getElementById(`capability-${inputId}`)?.value;
        const statusEl = document.getElementById(`status-${inputId}`);
        const configDiv = document.getElementById(`input-config-${inputId}`);
        
        if (deviceId && capability) {
          if (statusEl) {
            statusEl.className = 'status complete';
            statusEl.textContent = '✓ Configured';
          }
          if (configDiv) configDiv.classList.add('complete');
          configuredCount++;
        } else {
          if (statusEl) {
            statusEl.className = 'status incomplete';
            statusEl.textContent = '⚠️ Not configured';
          }
          if (configDiv) configDiv.classList.remove('complete');
          allConfigured = false;
        }
      }

      const summaryEl = document.getElementById('summary');
      if (summaryEl) {
        summaryEl.innerHTML = `<strong>Status:</strong> ${configuredCount} of ${numInputs} inputs configured`;
      }

      const btn = document.getElementById('complete-btn');
      if (allConfigured) {
        saveConfigToBackend();
        btn.innerHTML = "Save and complete"
        btn.className = "btn-enabled";
      } else {
        btn.innerHTML = "..."
        btn.className = "btn-disabled";
      }
    }

    init();
</script>
</body>
</html>
--- END: drivers/logic-device/pair/configure_inputs.html ---

--- START: drivers/logic-device/pair/select_num_inputs.html (sha256=6e8f17ebb5cf253413e383a5f13fb15c12a32f8bae82bfe594b5df0671e56d8b, bytes=2842) ---
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      text-align: center;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 500px;
      margin: 0 auto;
      background-color: white;
      padding: 40px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h2 {
      margin-bottom: 10px;
      color: #333;
    }
    .description {
      color: #666;
      margin: 20px 0 40px 0;
      line-height: 1.5;
    }
    .input-selector {
      margin: 40px auto;
    }
    .input-number {
      width: 120px;
      height: 80px;
      font-size: 32px;
      text-align: center;
      border: 2px solid #4CAF50;
      border-radius: 8px;
      font-weight: bold;
      color: #4CAF50;
    }
    .input-number:focus {
      outline: none;
      border-color: #45a049;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
    }
    .range-info {
      margin-top: 15px;
      color: #888;
      font-size: 14px;
    }
    button {
      padding: 15px 40px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      margin-top: 40px;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Select number of inputs</h2>
    <p class="description">How many devices do you want to connect to this logic device?</p>
    
    <div class="input-selector">
      <input type="number" id="numInputs" class="input-number" min="2" max="10" value="2">
      <div class="range-info">Choose between 2 and 10 inputs</div>
    </div>

    <button id="continue-btn">Next →</button>
  </div>

  <script>
    const numInputsEl = document.getElementById('numInputs');
    
    async function init() {
      try {
        const result = await Homey.emit('get_num_inputs');
        numInputsEl.value = result.numInputs || 2;
      } catch (e) {
        console.error('Init error:', e);
      }
    }

    numInputsEl.addEventListener('change', async (e) => {
      let value = parseInt(e.target.value);
      if (isNaN(value) || value < 2) value = 2;
      if (value > 10) value = 10;
      e.target.value = value;
      
      try {
        await Homey.emit('set_num_inputs', { numInputs: value });
      } catch (e) {
        console.error('Error setting num inputs:', e);
      }
    });

    document.getElementById('continue-btn').addEventListener('click', () => {
      Homey.nextView();
    });

    init();
  </script>
</body>
</html>
--- END: drivers/logic-device/pair/select_num_inputs.html ---

--- START: drivers/logic-unit-10/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-10/device.js ---

--- START: drivers/logic-unit-10/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-10/driver.js ---

--- START: drivers/logic-unit-2/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-2/device.js ---

--- START: drivers/logic-unit-2/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-2/driver.js ---

--- START: drivers/logic-unit-3/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-3/device.js ---

--- START: drivers/logic-unit-3/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-3/driver.js ---

--- START: drivers/logic-unit-4/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-4/device.js ---

--- START: drivers/logic-unit-4/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-4/driver.js ---

--- START: drivers/logic-unit-5/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-5/device.js ---

--- START: drivers/logic-unit-5/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-5/driver.js ---

--- START: drivers/logic-unit-6/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-6/device.js ---

--- START: drivers/logic-unit-6/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-6/driver.js ---

--- START: drivers/logic-unit-7/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-7/device.js ---

--- START: drivers/logic-unit-7/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-7/driver.js ---

--- START: drivers/logic-unit-8/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-8/device.js ---

--- START: drivers/logic-unit-8/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-8/driver.js ---

--- START: drivers/logic-unit-9/device.js (sha256=618d12bd866656e833a60e1d9980b4ee9d91f3024b7a87b4151fff3f9f865128, bytes=236) ---
'use strict';

const BaseLogicUnit = require('../../lib/BaseLogicUnit');

module.exports = class LogicUnit2Device extends BaseLogicUnit {
  // Alt annet er arvet fra BaseLogicUnit
  // Kan overstyre metoder her hvis nødvendig
};
--- END: drivers/logic-unit-9/device.js ---

--- START: drivers/logic-unit-9/driver.js (sha256=e158de4304bb228bf6436b0b34582f1cee61c48cf2b92abc1197e1d0e6121cf7, bytes=176) ---
'use strict';

const BaseLogicDriver = require('../../lib/BaseLogicDriver');

module.exports = class LogicUnit2Driver extends BaseLogicDriver {
  // Alt annet er arvet
};
--- END: drivers/logic-unit-9/driver.js ---

--- START: lib/BaseLogicDriver.js (sha256=948026346e35b426caa0ab5b4faf9e2986609ea6680d8df68dd45e11be34955e, bytes=1609) ---
'use strict';
const Homey = require('homey');

module.exports = class BaseLogicDriver extends Homey.Driver {
  async onInit() {
    const driverId = this.id;
    const numInputs = parseInt(driverId.split('-').pop());
    this.numInputs = numInputs;
    this.log(`Logic Unit Driver (${this.numInputs} inputs) has been initialized`);
  }

  // Sikrer unikt navn: "X 2", "X 3", ...
  async ensureUniqueDeviceName(name) {
    try {
      if (!this.homey.app.api) return name; // fallback hvis API ikke er klart
      const all = await this.homey.app.api.devices.getDevices();
      const existing = new Set(
        Object.values(all).map(d => (d?.name || '').trim()).filter(Boolean)
      );

      if (!existing.has(name)) return name;

      const base = name.replace(/\s+\d+$/, '').trim();
      const m = name.match(/\s+(\d+)$/);
      let n = m ? (parseInt(m[1], 10) + 1) : 2;

      let candidate = `${base} ${n}`;
      while (existing.has(candidate)) {
        n++;
        candidate = `${base} ${n}`;
      }
      return candidate;
    } catch (e) {
      this.error('ensureUniqueDeviceName failed:', e.message);
      return name; // ikke kræsje ved feil
    }
  }

  async onPair(session) {
    session.setHandler('list_devices', async () => {
      const baseName = `Logic Unit (${this.numInputs} inputs)`;
      const name = await this.ensureUniqueDeviceName(baseName);
      return [{
        name,
        data: {
          id: `logic-unit-${this.numInputs}-${Date.now()}`,
          numInputs: this.numInputs
        }
      }];
    });
  }
};
--- END: lib/BaseLogicDriver.js ---

--- START: lib/BaseLogicUnit.js (sha256=9812b93556a3bc1c939ef9ab931f7573bbb803797c75a318c6bee703249a7ef7, bytes=13988) ---
'use strict';
const Homey = require('homey');

module.exports = class BaseLogicUnit extends Homey.Device {
  // Trygg capability-oppdatering (ignorer 404, stopp ved sletting)
  async safeSetCapabilityValue(cap, value) {
    if (this._isDeleting) return;
    try {
      if (!this.hasCapability(cap)) return;
      await this.setCapabilityValue(cap, value);
    } catch (e) {
      const msg = e?.message || '';
      if (e?.statusCode === 404 || /not\s*found/i.test(msg)) {
        this.log(`(safe) Skipper ${cap} – enheten finnes ikke lenger.`);
        return;
      }
      this.error(`Capability update failed for ${cap}:`, msg);
    }
  }

  async onInit() {
    this.log(`Logic Unit '${this.getName()}' initializing.`);
    if (!this.hasCapability('onoff')) {
      await this.addCapability('onoff');
    }

    // Get number of inputs from device data
    this.numInputs = this.getData().numInputs ?? 5;
    this.availableInputs = this.getAvailableInputIds();

    this.initializeFormulas();
    await this.evaluateAllFormulasInitial(); // sett onoff=false hvis ingenting kan evalueres
    this.startTimeoutChecks();
  }

  getAvailableInputIds() {
    const allInputs = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
    return allInputs.slice(0, this.numInputs);
  }

  getAvailableInputsUppercase() {
    return this.availableInputs.map(i => i.toUpperCase());
  }

  // Initialize formulas from settings
  initializeFormulas() {
    const settings = this.getSettings();
    try {
      const formulasData = settings.formulas ? JSON.parse(settings.formulas) : [];
      // Initialize each formula with its own input state and timeout
      this.formulas = formulasData.map(f => ({
        id: f.id,
        name: f.name,
        expression: f.expression,
        enabled: f.enabled !== false,
        timeout: f.timeout ?? 0,
        firstImpression: f.firstImpression !== false && f.firstImpression !== 0,
        inputStates: {},
        lockedInputs: {},
        lastInputTime: null,
        result: null,
        timedOut: false
      }));
      // Initialize input states for each formula
      this.formulas.forEach(formula => {
        this.availableInputs.forEach(id => {
          formula.inputStates[id] = 'undefined';
          formula.lockedInputs[id] = false;
        });
      });
    } catch (e) {
      this.error('Failed to parse formulas:', e);
      this.formulas = [];
    }

    // Ensure we have at least one default formula
    if (this.formulas.length === 0) {
      const defaultFormula = {
        id: 'formula_1',
        name: 'Formula 1',
        expression: this.getDefaultExpression(),
        enabled: true,
        timeout: 0,
        firstImpression: true,
        inputStates: {},
        lockedInputs: {},
        lastInputTime: null,
        result: null,
        timedOut: false
      };
      this.availableInputs.forEach(id => {
        defaultFormula.inputStates[id] = 'undefined';
        defaultFormula.lockedInputs[id] = false;
      });
      this.formulas = [defaultFormula];
    }
  }

  getDefaultExpression() {
    const inputs = this.getAvailableInputsUppercase();
    return inputs.join(' AND ');
  }

  // Get all enabled formulas for autocomplete
  getFormulas() {
    return this.formulas
      .filter(f => f.enabled)
      .map(f => ({
        id: f.id,
        name: f.name,
        description: f.expression ?? '(no expression)'
      }));
  }

  // Get available inputs for dropdown
  getInputOptions() {
    return this.getAvailableInputsUppercase().map(input => ({
      id: input.toLowerCase(),
      name: input
    }));
  }

  // Validate boolean expression (enkel validering + syntaks-test)
  validateExpression(expression) {
    if (!expression || expression.trim() === '') {
      return { valid: false, error: 'Expression cannot be empty' };
    }

    const inputs = this.getAvailableInputsUppercase();

    // Normaliser alias til JS-operatorer og sjekk syntaks
    let testExpr = expression
      .toUpperCase()
      .replace(/\bAND\b|&&|\*/g, '&&')
      .replace(/\bOR\b|\|\||\+/g, '||')
      .replace(/\bXOR\b|\^|!=/g, '!=')   // boolsk XOR ~= ulikhet
      .replace(/\bNOT\b|!/g, '!');

    for (const key of inputs) {
      const regex = new RegExp(`\\b${key}\\b`, 'g');
      testExpr = testExpr.replace(regex, 'true');
    }

    // Parentesbalanse
    let depth = 0;
    for (const ch of testExpr) {
      if (ch === '(') depth++;
      else if (ch === ')') depth--;
      if (depth < 0) return { valid: false, error: 'Unbalanced parentheses' };
    }
    if (depth !== 0) return { valid: false, error: 'Unbalanced parentheses' };

    try {
      // eslint-disable-next-line no-new-func
      const fn = new Function(`return ${testExpr}`);
      void fn();
      return { valid: true };
    } catch (e) {
      return { valid: false, error: `Invalid expression syntax: ${e.message}` };
    }
  }

  // Parse expression to find required inputs
  parseExpression(expression) {
    const inputs = this.getAvailableInputsUppercase();
    const pattern = new RegExp(`\\b(${inputs.join('|')})\\b`, 'gi');
    const matches = expression.match(pattern);
    return matches ? [...new Set(matches.map(char => char.toUpperCase()))] : [];
  }

  // Set input value for a specific formula
  async setInputForFormula(formulaId, inputId, value) {
    if (this._isDeleting) return null;

    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula) {
      this.log(`Formula '${formulaId}' not found.`);
      return null;
    }

    if (formula.firstImpression && formula.lockedInputs[inputId]) {
      this.log(
        `Input '${inputId.toUpperCase()}' is locked for '${formula.name}' (first impression) – ignoring update`
      );
      return formula.result;
    }

    const oldValue = formula.inputStates[inputId];
    this.log(`Setting input '${inputId.toUpperCase()}' to ${value} for '${formula.name}' (was: ${oldValue})`);

    formula.inputStates[inputId] = value;
    formula.timedOut = false;

    if (formula.firstImpression && value !== 'undefined' && !formula.lockedInputs[inputId]) {
      formula.lockedInputs[inputId] = true;
      this.log(`🔒 Input '${inputId.toUpperCase()}' locked at value ${value} (first impression)`);
    }

    if (value !== 'undefined') {
      formula.lastInputTime = Date.now();
    }

    return await this.evaluateFormula(formulaId);
  }

  // Evaluate specific formula by ID
  async evaluateFormula(formulaId, resetLocks = false) {
    if (this._isDeleting) return null;

    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula || !formula.enabled) {
      this.log(`Formula '${formulaId}' not found or disabled.`);
      return null;
    }

    if (resetLocks && formula.firstImpression) {
      this.availableInputs.forEach(id => { formula.lockedInputs[id] = false; });
      this.log(`🔓 Unlocked all inputs for formula '${formula.name}'`);
    }

    const expression = formula.expression;
    if (!expression) {
      this.log('No expression set, cannot evaluate.');
      return null;
    }

    const requiredInputs = this.parseExpression(expression);
    if (requiredInputs.length === 0) return null;

    const allDefined = requiredInputs.every(id =>
      formula.inputStates[id.toLowerCase()] !== 'undefined'
    );
    if (!allDefined) {
      this.log(`Formula '${formula.name}': Waiting for inputs. Required: [${requiredInputs.join(', ')}]`);
      return null;
    }

    const values = {};
    this.availableInputs.forEach(id => { values[id.toUpperCase()] = formula.inputStates[id]; });

    this.log(`Formula '${formula.name}': Evaluating with inputs:`, values);

    // Normaliser alias til JS-operatorer
    let evalExpression = expression
      .replace(/\bAND\b|&&|\*/gi, '&&')
      .replace(/\bOR\b|\|\||\+/gi, '||')
      .replace(/\bXOR\b|\^|!=/gi, '!=')   // boolsk XOR ~= ulikhet
      .replace(/\bNOT\b|!/gi, '!');

    // Sett inn boolske verdier
    for (const key in values) {
      if (values[key] !== 'undefined') {
        const re = new RegExp(`\\b${key}\\b`, 'gi');
        evalExpression = evalExpression.replace(re, values[key]);
      }
    }

    this.log(`Evaluating: "${expression}" → "${evalExpression}"`);
    try {
      // eslint-disable-next-line no-new-func
      const fn = new Function(`return ${evalExpression}`);
      const result = !!fn();

      this.log(`✅ Formula '${formula.name}' result: ${result}`);

      const previous = formula.result;
      formula.result = result;
      formula.timedOut = false;

      // Logic Unit har kun 'onoff' – oppdater trygt
      await this.safeSetCapabilityValue('onoff', result);

      // (Evt. flow-triggers kan legges til her)
      return result;
    } catch (e) {
      this.error(`❌ Failed to evaluate formula '${formula.name}': ${e.message}`);
      return null;
    }
  }

  // Evaluate all enabled formulas (manuell re-evaluering)
  async evaluateAllFormulas() {
    this.log('Re-evaluating all formulas (resetting locks)...');
    const results = [];
    for (const formula of this.formulas) {
      if (formula.enabled) {
        this.availableInputs.forEach(id => { formula.lockedInputs[id] = false; });
        this.log(`🔓 Unlocked all inputs for formula '${formula.name}'`);
        const result = await this.evaluateFormula(formula.id);
        results.push({ id: formula.id, name: formula.name, result });
      }
    }
    this.log(`Evaluated ${results.length} formulas`);
    return results;
  }

  // Get formula result
  getFormulaResult(formulaId) {
    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula) {
      this.log(`getFormulaResult: Formula '${formulaId}' not found`);
      return null;
    }
    this.log(
      `getFormulaResult: Formula '${formula.name}' (${formulaId}) result = ${formula.result} (type: ${typeof formula.result})`
    );
    return formula ? formula.result : null;
  }

  // Check if formula has timed out
  hasFormulaTimedOut(formulaId) {
    const formula = this.formulas.find(f => f.id === formulaId);
    if (!formula) return false;
    return formula.timedOut;
  }

  // Start timeout checks
  startTimeoutChecks() {
    this.timeoutInterval = setInterval(() => {
      this.checkTimeouts();
    }, 1000);
  }

  // Check all formulas for timeouts
  checkTimeouts() {
    const now = Date.now();
    this.formulas.forEach(formula => {
      if (!formula.timeout || formula.timeout <= 0) return;
      if (formula.timedOut || !formula.enabled) return;
      if (!formula.lastInputTime) return;

      const hasAnyInput = this.availableInputs.some(id =>
        formula.inputStates[id] !== 'undefined'
      );
      if (!hasAnyInput) return;

      const requiredInputs = this.parseExpression(formula.expression);
      const allInputsDefined = requiredInputs.every(id =>
        formula.inputStates[id.toLowerCase()] !== 'undefined'
      );
      if (allInputsDefined) return;

      const timeoutMs = formula.timeout * 1000;
      const elapsed = now - formula.lastInputTime;
      if (elapsed >= timeoutMs) {
        this.log(`⏱️ Formula '${formula.name}' timed out after ${formula.timeout}s`);
        formula.timedOut = true;

        const triggerData = { formula: { id: formula.id, name: formula.name } };
        const state = { formulaId: formula.id };
        this.homey.flow.getDeviceTriggerCard('formula_timeout')
          .trigger(this, triggerData, state)
          .catch(err => this.error('Error triggering timeout:', err));
      }
    });
  }

  async onSettings({ oldSettings, newSettings, changedKeys }) {
    this.log('Settings changed. Reinitializing formulas.');
    if (this.timeoutInterval) {
      clearInterval(this.timeoutInterval);
    }

    this.initializeFormulas();
    await this.evaluateAllFormulasInitial(); // konsekvent init etter settings

    if (changedKeys.includes('formulas')) {
      for (const formula of this.formulas) {
        const validation = this.validateExpression(formula.expression);
        if (!validation.valid) {
          throw new Error(`Formula '${formula.name}': ${validation.error}`);
        }
      }
    }
    this.startTimeoutChecks();
  }

  async onDeleted() {
    this._isDeleting = true;
    this.log('Logic Unit deleted — cleaning up timers');
    if (this.timeoutInterval) {
      clearInterval(this.timeoutInterval);
      this.timeoutInterval = null;
    }
    this.log('Cleanup complete');
  }

  // Initial evaluering (på init og etter settings)
  async evaluateAllFormulasInitial() {
    this.log('Initial evaluation of all formulas...');
    let anyEvaluated = false;

    for (const formula of this.formulas) {
      if (!formula.enabled) continue;
      const expr = formula.expression;
      if (!expr) continue;

      const required = this.parseExpression(expr);
      if (!required.length) continue;

      const allDefined = required.every(id =>
        formula.inputStates[id.toLowerCase()] !== 'undefined'
      );

      if (allDefined) {
        this.log(`Formula '${formula.name}': All inputs defined, evaluating...`);
        await this.evaluateFormula(formula.id);
        anyEvaluated = true;
      } else {
        const states = {};
        required.forEach(id => { states[id] = formula.inputStates[id.toLowerCase()]; });
        this.log(`Formula '${formula.name}': Missing inputs:`, states);
      }
    }

    if (!anyEvaluated) {
      this.log('⚠️ No formulas could be evaluated - waiting for input values');
      await this.safeSetCapabilityValue('onoff', false);
    }
  }
};
--- END: lib/BaseLogicUnit.js ---

--- START: package-lock.json (sha256=1eccaf12f8750c2763571ac370fb0c9bd59b503c15fcc06b87544b679851e475, bytes=586) ---
{
  "name": "no.tiwas.booleantoolbox",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "no.tiwas.booleantoolbox",
      "version": "0.1.0",
      "license": "ISC",
      "dependencies": {
        "athom-api": "^3.9.2"
      }
    },
    "node_modules/athom-api": {
      "version": "3.9.2",
      "resolved": "https://registry.npmjs.org/athom-api/-/athom-api-3.9.2.tgz",
      "integrity": "sha512-0bV75q/MJq6+/5H33RC+yImqf+ww69mgAqrf4IBaM/UcNDU8ZHTxNk9Q+aHP+h7sh8QssV3P45TeTwRXVg3tbw==",
      "license": "GPL-3.0"
    }
  }
}
--- END: package-lock.json ---

--- START: package.json (sha256=0b13dfe912bbcdd09639b196c531b845409f68c5b260ad53ef5ce238f6987a56, bytes=296) ---
{
  "name": "no.tiwas.booleantoolbox",
  "version": "1.1.1",
  "main": "app.js",
  "dependencies": {
    "athom-api": "^3.5.0"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "Lars Kvanum",
  "license": "ISC",
  "description": ""
}
--- END: package.json ---

